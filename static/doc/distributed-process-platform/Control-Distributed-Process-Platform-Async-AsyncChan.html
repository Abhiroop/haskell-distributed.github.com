<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Control.Distributed.Process.Platform.Async.AsyncChan</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Control-Distributed-Process-Platform-Async-AsyncChan.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">distributed-process-platform-0.1.0: The Cloud Haskell Application Platform</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Portability</th><td>non-portable (requires concurrency)</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Maintainer</th><td>Tim Watson &lt;watson.timothy@gmail.com&gt;</td></tr><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Control.Distributed.Process.Platform.Async.AsyncChan</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Exported types
</a></li><li><a href="#g:2">Spawning asynchronous operations
</a></li><li><a href="#g:3">Cancelling asynchronous operations
</a></li><li><a href="#g:4">Querying for results
</a></li><li><a href="#g:5">Waiting with timeouts
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module provides a set of operations for spawning Process operations
 and waiting for their results.  It is a thin layer over the basic
 concurrency operations provided by <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process.html">Control.Distributed.Process</a>.
 The main feature it provides is a pre-canned set of APIs for waiting on the
 result of one or more asynchronously running (and potentially distributed)
 processes.
</p><p>The async handles returned by this module cannot be used by processes other
 than the caller of <code><a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#v:async">async</a></code>, and are not <code><a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a></code>. Specifically, calls
 that block until an async worker completes (i.e., all variants of <code><a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#v:wait">wait</a></code>)
 will <em>never return</em> if called from a different process.
</p><pre> h &lt;- newEmptyMVar
 outer &lt;- spawnLocal $ async runMyAsyncTask &gt;&gt;= liftIO $ putMVar h
 hAsync &lt;- liftIO $ takeMVar h
 say &quot;this expression will never return, because hAsync belongs to 'outer'&quot;
 wait hAsync
</pre><p>As with <code><a href="Control-Distributed-Platform-Async.html#t:Async">Async</a></code>, workers can be
 started on a local or remote node.
</p><p>See <a href="Control-Distributed-Platform-Async.html">Control.Distributed.Platform.Async</a>.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">type</span> <a href="#t:AsyncRef">AsyncRef</a> = <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:ProcessId">ProcessId</a></li><li class="src short"><span class="keyword">data</span>  <a href="#t:AsyncTask">AsyncTask</a> a<ul class="subs"><li>= <a href="#v:AsyncTask">AsyncTask</a> { <ul class="subs"><li><a href="#v:asyncTask">asyncTask</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> a</li></ul> }</li><li>| <a href="#v:AsyncRemoteTask">AsyncRemoteTask</a> { <ul class="subs"><li><a href="#v:asyncTaskDict">asyncTaskDict</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process.html#t:Static">Static</a> (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:SerializableDict">SerializableDict</a> a)</li><li><a href="#v:asyncTaskNode">asyncTaskNode</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:NodeId">NodeId</a></li><li><a href="#v:asyncTaskProc">asyncTaskProc</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process.html#t:Closure">Closure</a> (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> a)</li></ul> }</li></ul></li><li class="src short"><span class="keyword">data</span>  <a href="#t:AsyncChan">AsyncChan</a> a</li><li class="src short"><span class="keyword">data</span>  <a href="#t:AsyncResult">AsyncResult</a> a<ul class="subs"><li>= <a href="#v:AsyncDone">AsyncDone</a> a  </li><li>| <a href="#v:AsyncFailed">AsyncFailed</a> <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:DiedReason">DiedReason</a>  </li><li>| <a href="#v:AsyncLinkFailed">AsyncLinkFailed</a> <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:DiedReason">DiedReason</a>  </li><li>| <a href="#v:AsyncCancelled">AsyncCancelled</a>  </li><li>| <a href="#v:AsyncPending">AsyncPending</a>  </li></ul></li><li class="src short"><span class="keyword">data</span>  <a href="#t:Async">Async</a> a</li><li class="src short"><a href="#v:async">async</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncTask">AsyncTask</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a)</li><li class="src short"><a href="#v:asyncLinked">asyncLinked</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncTask">AsyncTask</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a)</li><li class="src short"><a href="#v:newAsync">newAsync</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncTask">AsyncTask</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a)) -&gt; <a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncTask">AsyncTask</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:Async">Async</a> a)</li><li class="src short"><a href="#v:cancel">cancel</a> ::  <a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html#t:-40--41-">()</a></li><li class="src short"><a href="#v:cancelWait">cancelWait</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncResult">AsyncResult</a> a)</li><li class="src short"><a href="#v:cancelWith">cancelWith</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b =&gt; b -&gt; <a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html#t:-40--41-">()</a></li><li class="src short"><a href="#v:cancelKill">cancelKill</a> ::  <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-String.html#t:String">String</a> -&gt; <a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html#t:-40--41-">()</a></li><li class="src short"><a href="#v:poll">poll</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncResult">AsyncResult</a> a)</li><li class="src short"><a href="#v:check">check</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncResult">AsyncResult</a> a))</li><li class="src short"><a href="#v:wait">wait</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncResult">AsyncResult</a> a)</li><li class="src short"><a href="#v:waitAny">waitAny</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; [<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a] -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncResult">AsyncResult</a> a)</li><li class="src short"><a href="#v:waitAnyCancel">waitAnyCancel</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; [<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a] -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncResult">AsyncResult</a> a)</li><li class="src short"><a href="#v:waitAnyTimeout">waitAnyTimeout</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; [<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a] -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncResult">AsyncResult</a> a))</li><li class="src short"><a href="#v:waitTimeout">waitTimeout</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; <a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncResult">AsyncResult</a> a))</li><li class="src short"><a href="#v:waitCancelTimeout">waitCancelTimeout</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; <a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncResult">AsyncResult</a> a)</li><li class="src short"><a href="#v:waitCheckTimeout">waitCheckTimeout</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; <a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncResult">AsyncResult</a> a)</li></ul></div><div id="interface"><h1 id="g:1">Exported types
</h1><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:AsyncRef" class="def">AsyncRef</a> = <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:ProcessId">ProcessId</a></p><div class="doc"><p>A reference to an asynchronous action
</p></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:AsyncTask" class="def">AsyncTask</a> a </p><div class="doc"><p>A task to be performed asynchronously.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:AsyncTask" class="def">AsyncTask</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:asyncTask" class="def">asyncTask</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> a</dt><dd class="doc"><p>the task to be performed
</p></dd></dl><div class="clear"></div></div></td></tr><tr><td class="src"><a name="v:AsyncRemoteTask" class="def">AsyncRemoteTask</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:asyncTaskDict" class="def">asyncTaskDict</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process.html#t:Static">Static</a> (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:SerializableDict">SerializableDict</a> a)</dt><dd class="doc"><p>the serializable dict required to spawn a remote process
</p></dd><dt class="src"><a name="v:asyncTaskNode" class="def">asyncTaskNode</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:NodeId">NodeId</a></dt><dd class="doc"><p>the node on which to spawn the asynchronous task
</p></dd><dt class="src"><a name="v:asyncTaskProc" class="def">asyncTaskProc</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process.html#t:Closure">Closure</a> (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> a)</dt><dd class="doc"><p>the task to be performed, wrapped in a closure environment
</p></dd></dl><div class="clear"></div></div></td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:AsyncChan" class="def">AsyncChan</a> a </p><div class="doc"><p>A handle for an asynchronous action spawned by <code><a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#v:async">async</a></code>.
 Asynchronous actions are run in a separate process, and
 operations are provided for waiting for asynchronous actions to
 complete and obtaining their results (see e.g. <code><a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#v:wait">wait</a></code>).
</p><p>Handles of this type cannot cross remote boundaries. Furthermore, handles
 of this type <em>must not</em> be passed to functions in this module by processes
 other than the caller of <code><a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#v:async">async</a></code> - that is, this module provides asynchronous
 actions whose results are accessible *only* by the initiating process. This
 limitation is imposed becuase of the use of typed channels, for which the
 <code>ReceivePort</code> component is effectively <em>thread local</em>.
</p><p>See <code><a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#v:async">async</a></code>
</p></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:AsyncResult" class="def">AsyncResult</a> a </p><div class="doc"><p>Represents the result of an asynchronous action, which can be in one of
 several states at any given time.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:AsyncDone" class="def">AsyncDone</a> a</td><td class="doc"><p>a completed action and its result
</p></td></tr><tr><td class="src"><a name="v:AsyncFailed" class="def">AsyncFailed</a> <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:DiedReason">DiedReason</a></td><td class="doc"><p>a failed action and the failure reason
</p></td></tr><tr><td class="src"><a name="v:AsyncLinkFailed" class="def">AsyncLinkFailed</a> <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:DiedReason">DiedReason</a></td><td class="doc"><p>a link failure and the reason
</p></td></tr><tr><td class="src"><a name="v:AsyncCancelled" class="def">AsyncCancelled</a></td><td class="doc"><p>a cancelled action
</p></td></tr><tr><td class="src"><a name="v:AsyncPending" class="def">AsyncPending</a></td><td class="doc"><p>a pending action (that is still running)
</p></td></tr></table></div><div class="subs instances"><p id="control.i:AsyncResult" class="caption collapser" onclick="toggleSection('i:AsyncResult')">Instances</p><div id="section.i:AsyncResult" class="show"><table><tr><td class="src"><a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Typeable-Internal.html#t:Typeable1">Typeable1</a> <a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncResult">AsyncResult</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Eq.html#t:Eq">Eq</a> a =&gt; <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Eq.html#t:Eq">Eq</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncResult">AsyncResult</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Text-Show.html#t:Show">Show</a> a =&gt; <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Text-Show.html#t:Show">Show</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncResult">AsyncResult</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/binary-0.5.1.0/Data-Binary.html#t:Binary">Binary</a> a_1627460136 =&gt; <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/binary-0.5.1.0/Data-Binary.html#t:Binary">Binary</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncResult">AsyncResult</a> a_1627460136)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Async" class="def">Async</a> a </p><div class="doc"><p>An opaque handle that refers to an asynchronous operation.
</p></div></div><h1 id="g:2">Spawning asynchronous operations
</h1><div class="top"><p class="src"><a name="v:async" class="def">async</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncTask">AsyncTask</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a)</p><div class="doc"><p>Spawns an asynchronous action in a new process.
 We ensure that if the caller's process exits, that the worker is killed.
 Because an <code>AsyncChan</code> can only be used by the initial caller's process, if
 that process dies then the result (if any) is discarded. If a process other
 than the initial caller attempts to obtain the result of an asynchronous
 action, the behaviour is undefined. It is <em>highly likely</em> that such a
 process will block indefinitely, quite possible that such behaviour could lead
 to deadlock and almost certain that resource starvation will occur. <em>Do Not</em>
 share the handles returned by this function across multiple processes.
</p><p>If you need to spawn an asynchronous operation whose handle can be shared by
 multiple processes then use the <code>AsyncSTM</code> module instead.
</p><p>There is currently a contract for async workers, that they should
 exit normally (i.e., they should not call the <code>exit</code> or <code>kill</code> with their own
 <code><a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:ProcessId">ProcessId</a></code> nor use the <code>terminate</code> primitive to cease functining), otherwise
 the <code><a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncResult">AsyncResult</a></code> will end up being <code>AsyncFailed DiedException</code> instead of
 containing the desired result.
</p></div></div><div class="top"><p class="src"><a name="v:asyncLinked" class="def">asyncLinked</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncTask">AsyncTask</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a)</p><div class="doc"><p>For *AsyncChan*, <code><a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#v:async">async</a></code> already ensures an <code>AsyncChan</code> is
 never left running unintentionally. This function is provided for compatibility
 with other <em>async</em> implementations that may offer different semantics for
 <code>async</code> with regards linking.
</p><pre>asyncLinked = async</pre></div></div><div class="top"><p class="src"><a name="v:newAsync" class="def">newAsync</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncTask">AsyncTask</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a)) -&gt; <a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncTask">AsyncTask</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:Async">Async</a> a)</p><div class="doc"><p>Create a new <code>AsyncChane</code> and wrap it in an <code><a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:Async">Async</a></code> record.
</p><p>Used by <a href="Control-Distributed-Process-Platform-Async.html">Control.Distributed.Process.Platform.Async</a>.
</p></div></div><h1 id="g:3">Cancelling asynchronous operations
</h1><div class="top"><p class="src"><a name="v:cancel" class="def">cancel</a> ::  <a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html#t:-40--41-">()</a></p><div class="doc"><p>Cancel an asynchronous operation. Cancellation is asynchronous in nature.
</p><p>See <a href="Control-Distributed-Process-Platform-Async.html">Control.Distributed.Process.Platform.Async</a>.
</p></div></div><div class="top"><p class="src"><a name="v:cancelWait" class="def">cancelWait</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncResult">AsyncResult</a> a)</p><div class="doc"><p>Cancel an asynchronous operation and wait for the cancellation to complete.
</p><p>See <a href="Control-Distributed-Process-Platform-Async.html">Control.Distributed.Process.Platform.Async</a>.
</p></div></div><div class="top"><p class="src"><a name="v:cancelWith" class="def">cancelWith</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b =&gt; b -&gt; <a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html#t:-40--41-">()</a></p><div class="doc"><p>Cancel an asynchronous operation immediately.
</p><p>See <a href="Control-Distributed-Process-Platform-Async.html">Control.Distributed.Process.Platform.Async</a>.
</p></div></div><div class="top"><p class="src"><a name="v:cancelKill" class="def">cancelKill</a> ::  <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-String.html#t:String">String</a> -&gt; <a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html#t:-40--41-">()</a></p><div class="doc"><p>Like <code><a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#v:cancelWith">cancelWith</a></code> but sends a <code>kill</code> instruction instead of an exit.
</p><p>See <a href="Control-Distributed-Process-Platform-Async.html">Control.Distributed.Process.Platform.Async</a>.
</p></div></div><h1 id="g:4">Querying for results
</h1><div class="top"><p class="src"><a name="v:poll" class="def">poll</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncResult">AsyncResult</a> a)</p><div class="doc"><p>Check whether an <code><a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a></code> has completed yet.
</p><p>See <a href="Control-Distributed-Process-Platform-Async.html">Control.Distributed.Process.Platform.Async</a>.
</p></div></div><div class="top"><p class="src"><a name="v:check" class="def">check</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncResult">AsyncResult</a> a))</p><div class="doc"><p>Like <code><a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#v:poll">poll</a></code> but returns <code><a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Maybe.html#v:Nothing">Nothing</a></code> if <code>(poll hAsync) == AsyncPending</code>.
</p><p>See <a href="Control-Distributed-Process-Platform-Async.html">Control.Distributed.Process.Platform.Async</a>.
</p></div></div><div class="top"><p class="src"><a name="v:wait" class="def">wait</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncResult">AsyncResult</a> a)</p><div class="doc"><p>Wait for an asynchronous action to complete, and return its
 value. The outcome of the action is encoded as an <code><a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncResult">AsyncResult</a></code>.
</p><p>See <a href="Control-Distributed-Process-Platform-Async.html">Control.Distributed.Process.Platform.Async</a>.
</p></div></div><div class="top"><p class="src"><a name="v:waitAny" class="def">waitAny</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; [<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a] -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncResult">AsyncResult</a> a)</p><div class="doc"><p>Wait for any of the supplied <code>AsyncChans</code>s to complete. If multiple
 <code><a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:Async">Async</a></code>s complete, then the value returned corresponds to the first
 completed <code><a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:Async">Async</a></code> in the list. Only <em>unread</em> <code><a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:Async">Async</a></code>s are of value here,
 because <code><a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a></code> does not hold on to its result after it has been read!
</p><p>This function is analagous to the <code>mergePortsBiased</code> primitive.
</p><p>See <a href="Control-Distibuted-Process-mergePortsBiased.html">Control.Distibuted.Process.mergePortsBiased</a>.
</p></div></div><div class="top"><p class="src"><a name="v:waitAnyCancel" class="def">waitAnyCancel</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; [<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a] -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncResult">AsyncResult</a> a)</p><div class="doc"><p>Like <code><a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#v:waitAny">waitAny</a></code>, but also cancels the other asynchronous
 operations as soon as one has completed.
</p></div></div><h1 id="g:5">Waiting with timeouts
</h1><div class="top"><p class="src"><a name="v:waitAnyTimeout" class="def">waitAnyTimeout</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; [<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a] -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncResult">AsyncResult</a> a))</p><div class="doc"><p>Like <code><a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#v:waitAny">waitAny</a></code> but times out after the specified delay.
</p></div></div><div class="top"><p class="src"><a name="v:waitTimeout" class="def">waitTimeout</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; <a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncResult">AsyncResult</a> a))</p><div class="doc"><p>Wait for an asynchronous operation to complete or timeout.
</p><p>See <a href="Control-Distributed-Process-Platform-Async.html">Control.Distributed.Process.Platform.Async</a>.
</p></div></div><div class="top"><p class="src"><a name="v:waitCancelTimeout" class="def">waitCancelTimeout</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; <a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncResult">AsyncResult</a> a)</p><div class="doc"><p>Wait for an asynchronous operation to complete or timeout. If it times out,
 then <code><a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#v:cancelWait">cancelWait</a></code> the async handle instead.
</p></div></div><div class="top"><p class="src"><a name="v:waitCheckTimeout" class="def">waitCheckTimeout</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; <a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncChan">AsyncChan</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncChan.html#t:AsyncResult">AsyncResult</a> a)</p><div class="doc"><p>Wait for an asynchronous operation to complete or timeout.
</p><p>See <a href="Control-Distributed-Process-Platform-Async.html">Control.Distributed.Process.Platform.Async</a>.
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.11.0</p></div></body></html>