<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Control.Distributed.Process.Platform.Async</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Control-Distributed-Process-Platform-Async.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">distributed-process-platform-0.1.0: The Cloud Haskell Application Platform</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Portability</th><td>non-portable (requires concurrency)</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Maintainer</th><td>Tim Watson &lt;watson.timothy@gmail.com&gt;</td></tr><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Control.Distributed.Process.Platform.Async</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Exported Types
</a></li><li><a href="#g:2">Spawning asynchronous operations
</a></li><li><a href="#g:3">Cancelling asynchronous operations
</a></li><li><a href="#g:4">Querying for results
</a></li><li><a href="#g:5">Waiting with timeouts
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>The <em>async</em> APIs provided by distributed-process-platform provide means
 for spawning asynchronous operations, waiting for their results, cancelling
 them and various other utilities. The two primary implementation are
 <code>AsyncChan</code> which provides a handle which is scoped to the calling process,
 and <code>AsyncSTM</code>, whose async mechanism can be used by (i.e., shared across)
 multiple local processes.
</p><p>Both abstractions can run asynchronous operations on remote nodes. The STM
 based implementation provides a slightly richer API. The API defined in
 <em>this</em> module only supports a subset of operations on async handles,
 and (specifically) does not support mixing handles initialised via
 different implementations.
</p><p>There is an implicit contract for async workers; Workers must exit
 normally (i.e., should not call the <code><a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Primitives.html#v:exit">exit</a></code>, <code><a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Primitives.html#v:die">die</a></code> or <code><a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Primitives.html#v:terminate">terminate</a></code>
 Cloud Haskell primitives), otherwise the <code><a href="Control-Distributed-Process-Platform-Async.html#t:AsyncResult">AsyncResult</a></code> will end up being
 <code>AsyncFailed DiedException</code> instead of containing the result.
</p><p>See <a href="Control-Distributed-Process-Platform-Async-AsyncSTM.html">Control.Distributed.Process.Platform.Async.AsyncSTM</a>,
 <a href="Control-Distributed-Process-Platform-Async-AsyncChan.html">Control.Distributed.Process.Platform.Async.AsyncChan</a>.
</p><p>See <a href="Control-Distributed-Platform-Task.html">Control.Distributed.Platform.Task</a> for a high level layer built
 on these capabilities.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span>  <a href="#t:Async">Async</a> a</li><li class="src short"><span class="keyword">type</span> <a href="#t:AsyncRef">AsyncRef</a> = <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:ProcessId">ProcessId</a></li><li class="src short"><span class="keyword">data</span>  <a href="#t:AsyncTask">AsyncTask</a> a<ul class="subs"><li>= <a href="#v:AsyncTask">AsyncTask</a> { <ul class="subs"><li><a href="#v:asyncTask">asyncTask</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> a</li></ul> }</li><li>| <a href="#v:AsyncRemoteTask">AsyncRemoteTask</a> { <ul class="subs"><li><a href="#v:asyncTaskDict">asyncTaskDict</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process.html#t:Static">Static</a> (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:SerializableDict">SerializableDict</a> a)</li><li><a href="#v:asyncTaskNode">asyncTaskNode</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:NodeId">NodeId</a></li><li><a href="#v:asyncTaskProc">asyncTaskProc</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process.html#t:Closure">Closure</a> (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> a)</li></ul> }</li></ul></li><li class="src short"><span class="keyword">data</span>  <a href="#t:AsyncResult">AsyncResult</a> a<ul class="subs"><li>= <a href="#v:AsyncDone">AsyncDone</a> a  </li><li>| <a href="#v:AsyncFailed">AsyncFailed</a> <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:DiedReason">DiedReason</a>  </li><li>| <a href="#v:AsyncLinkFailed">AsyncLinkFailed</a> <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:DiedReason">DiedReason</a>  </li><li>| <a href="#v:AsyncCancelled">AsyncCancelled</a>  </li><li>| <a href="#v:AsyncPending">AsyncPending</a>  </li></ul></li><li class="src short"><a href="#v:async">async</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a)</li><li class="src short"><a href="#v:asyncLinked">asyncLinked</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a)</li><li class="src short"><a href="#v:asyncSTM">asyncSTM</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Async.html#t:AsyncTask">AsyncTask</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a)</li><li class="src short"><a href="#v:asyncLinkedSTM">asyncLinkedSTM</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Async.html#t:AsyncTask">AsyncTask</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a)</li><li class="src short"><a href="#v:asyncChan">asyncChan</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Async.html#t:AsyncTask">AsyncTask</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a)</li><li class="src short"><a href="#v:asyncLinkedChan">asyncLinkedChan</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Async.html#t:AsyncTask">AsyncTask</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a)</li><li class="src short"><a href="#v:task">task</a> ::  <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> a -&gt; <a href="Control-Distributed-Process-Platform-Async.html#t:AsyncTask">AsyncTask</a> a</li><li class="src short"><a href="#v:remoteTask">remoteTask</a> ::  <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process.html#t:Static">Static</a> (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:SerializableDict">SerializableDict</a> a) -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:NodeId">NodeId</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process.html#t:Closure">Closure</a> (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> a) -&gt; <a href="Control-Distributed-Process-Platform-Async.html#t:AsyncTask">AsyncTask</a> a</li><li class="src short"><a href="#v:cancel">cancel</a> ::  <a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html#t:-40--41-">()</a></li><li class="src short"><a href="#v:cancelWait">cancelWait</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async.html#t:AsyncResult">AsyncResult</a> a)</li><li class="src short"><a href="#v:cancelWith">cancelWith</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b =&gt; b -&gt; <a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html#t:-40--41-">()</a></li><li class="src short"><a href="#v:cancelKill">cancelKill</a> ::  <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-String.html#t:String">String</a> -&gt; <a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html#t:-40--41-">()</a></li><li class="src short"><a href="#v:poll">poll</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async.html#t:AsyncResult">AsyncResult</a> a)</li><li class="src short"><a href="#v:check">check</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Control-Distributed-Process-Platform-Async.html#t:AsyncResult">AsyncResult</a> a))</li><li class="src short"><a href="#v:wait">wait</a> ::  <a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async.html#t:AsyncResult">AsyncResult</a> a)</li><li class="src short"><a href="#v:waitTimeout">waitTimeout</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; <a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Control-Distributed-Process-Platform-Async.html#t:AsyncResult">AsyncResult</a> a))</li><li class="src short"><a href="#v:waitCancelTimeout">waitCancelTimeout</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; <a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async.html#t:AsyncResult">AsyncResult</a> a)</li><li class="src short"><a href="#v:waitCheckTimeout">waitCheckTimeout</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; <a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async.html#t:AsyncResult">AsyncResult</a> a)</li></ul></div><div id="interface"><h1 id="g:1">Exported Types
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Async" class="def">Async</a> a </p><div class="doc"><p>An opaque handle that refers to an asynchronous operation.
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:AsyncRef" class="def">AsyncRef</a> = <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:ProcessId">ProcessId</a></p><div class="doc"><p>A reference to an asynchronous action
</p></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:AsyncTask" class="def">AsyncTask</a> a </p><div class="doc"><p>A task to be performed asynchronously.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:AsyncTask" class="def">AsyncTask</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:asyncTask" class="def">asyncTask</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> a</dt><dd class="doc"><p>the task to be performed
</p></dd></dl><div class="clear"></div></div></td></tr><tr><td class="src"><a name="v:AsyncRemoteTask" class="def">AsyncRemoteTask</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:asyncTaskDict" class="def">asyncTaskDict</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process.html#t:Static">Static</a> (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:SerializableDict">SerializableDict</a> a)</dt><dd class="doc"><p>the serializable dict required to spawn a remote process
</p></dd><dt class="src"><a name="v:asyncTaskNode" class="def">asyncTaskNode</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:NodeId">NodeId</a></dt><dd class="doc"><p>the node on which to spawn the asynchronous task
</p></dd><dt class="src"><a name="v:asyncTaskProc" class="def">asyncTaskProc</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process.html#t:Closure">Closure</a> (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> a)</dt><dd class="doc"><p>the task to be performed, wrapped in a closure environment
</p></dd></dl><div class="clear"></div></div></td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:AsyncResult" class="def">AsyncResult</a> a </p><div class="doc"><p>Represents the result of an asynchronous action, which can be in one of
 several states at any given time.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:AsyncDone" class="def">AsyncDone</a> a</td><td class="doc"><p>a completed action and its result
</p></td></tr><tr><td class="src"><a name="v:AsyncFailed" class="def">AsyncFailed</a> <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:DiedReason">DiedReason</a></td><td class="doc"><p>a failed action and the failure reason
</p></td></tr><tr><td class="src"><a name="v:AsyncLinkFailed" class="def">AsyncLinkFailed</a> <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:DiedReason">DiedReason</a></td><td class="doc"><p>a link failure and the reason
</p></td></tr><tr><td class="src"><a name="v:AsyncCancelled" class="def">AsyncCancelled</a></td><td class="doc"><p>a cancelled action
</p></td></tr><tr><td class="src"><a name="v:AsyncPending" class="def">AsyncPending</a></td><td class="doc"><p>a pending action (that is still running)
</p></td></tr></table></div><div class="subs instances"><p id="control.i:AsyncResult" class="caption collapser" onclick="toggleSection('i:AsyncResult')">Instances</p><div id="section.i:AsyncResult" class="show"><table><tr><td class="src"><a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Typeable-Internal.html#t:Typeable1">Typeable1</a> <a href="Control-Distributed-Process-Platform-Async.html#t:AsyncResult">AsyncResult</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Eq.html#t:Eq">Eq</a> a =&gt; <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Eq.html#t:Eq">Eq</a> (<a href="Control-Distributed-Process-Platform-Async.html#t:AsyncResult">AsyncResult</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Text-Show.html#t:Show">Show</a> a =&gt; <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Text-Show.html#t:Show">Show</a> (<a href="Control-Distributed-Process-Platform-Async.html#t:AsyncResult">AsyncResult</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/binary-0.5.1.0/Data-Binary.html#t:Binary">Binary</a> a_1627460136 =&gt; <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/binary-0.5.1.0/Data-Binary.html#t:Binary">Binary</a> (<a href="Control-Distributed-Process-Platform-Async.html#t:AsyncResult">AsyncResult</a> a_1627460136)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:2">Spawning asynchronous operations
</h1><div class="top"><p class="src"><a name="v:async" class="def">async</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a)</p><div class="doc"><p>Spawn an <code><a href="Control-Distributed-Process-Platform-Async.html#t:AsyncTask">AsyncTask</a></code> and return the <code><a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a></code> handle to it.
 See <code><a href="Control-Distributed-Process-Platform-Async.html#v:asyncSTM">asyncSTM</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:asyncLinked" class="def">asyncLinked</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a)</p><div class="doc"><p>Spawn an <code><a href="Control-Distributed-Process-Platform-Async.html#t:AsyncTask">AsyncTask</a></code> (linked to the calling process) and
 return the <code><a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a></code> handle to it.
 See <code><a href="Control-Distributed-Process-Platform-Async.html#v:asyncSTM">asyncSTM</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:asyncSTM" class="def">asyncSTM</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Async.html#t:AsyncTask">AsyncTask</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a)</p><div class="doc"><p>Spawn an <code><a href="Control-Distributed-Process-Platform-Async.html#t:AsyncTask">AsyncTask</a></code> and return the <code><a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a></code> handle to it.
 Uses the STM implementation, whose handles can be read by other
 processes, though they're not <code>Serializable</code>.
</p><p>See <code><a href="Control-Distributed-Process-Platform-Async.html#t:AsyncSTM">AsyncSTM</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:asyncLinkedSTM" class="def">asyncLinkedSTM</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Async.html#t:AsyncTask">AsyncTask</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a)</p><div class="doc"><p>Spawn an <code><a href="Control-Distributed-Process-Platform-Async.html#t:AsyncTask">AsyncTask</a></code> (linked to the calling process) and return the
 <code><a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a></code> handle to it. Uses the STM based implementation, whose handles
 can be read by other processes, though they're not <code>Serializable</code>.
</p><p>See <code><a href="Control-Distributed-Process-Platform-Async.html#t:AsyncSTM">AsyncSTM</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:asyncChan" class="def">asyncChan</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Async.html#t:AsyncTask">AsyncTask</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a)</p><div class="doc"><p>Spawn an <code><a href="Control-Distributed-Process-Platform-Async.html#t:AsyncTask">AsyncTask</a></code> and return the <code><a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a></code> handle to it.
 Uses a channel based implementation, whose handles can only be read once,
 and only by the calling process.
</p><p>See <code><a href="Control-Distributed-Process-Platform-Async.html#t:AsyncChan">AsyncChan</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:asyncLinkedChan" class="def">asyncLinkedChan</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Async.html#t:AsyncTask">AsyncTask</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a)</p><div class="doc"><p>Linked version of <code><a href="Control-Distributed-Process-Platform-Async.html#v:asyncChan">asyncChan</a></code>.
</p><p>See <code><a href="Control-Distributed-Process-Platform-Async.html#t:AsyncChan">AsyncChan</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:task" class="def">task</a> ::  <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> a -&gt; <a href="Control-Distributed-Process-Platform-Async.html#t:AsyncTask">AsyncTask</a> a</p><div class="doc"><p>Wraps a regular <code>Process a</code> as an <code><a href="Control-Distributed-Process-Platform-Async.html#t:AsyncTask">AsyncTask</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:remoteTask" class="def">remoteTask</a> ::  <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process.html#t:Static">Static</a> (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:SerializableDict">SerializableDict</a> a) -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:NodeId">NodeId</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process.html#t:Closure">Closure</a> (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> a) -&gt; <a href="Control-Distributed-Process-Platform-Async.html#t:AsyncTask">AsyncTask</a> a</p><div class="doc"><p>Wraps the components required and builds a remote <code><a href="Control-Distributed-Process-Platform-Async.html#t:AsyncTask">AsyncTask</a></code>.
</p></div></div><h1 id="g:3">Cancelling asynchronous operations
</h1><div class="top"><p class="src"><a name="v:cancel" class="def">cancel</a> ::  <a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html#t:-40--41-">()</a></p><div class="doc"><p>Cancel an asynchronous operation. Cancellation is asynchronous in nature.
 To wait for cancellation to complete, use <code><a href="Control-Distributed-Process-Platform-Async.html#v:cancelWait">cancelWait</a></code> instead. The notes
 about the asynchronous nature of <code><a href="Control-Distributed-Process-Platform-Async.html#v:cancelWait">cancelWait</a></code> apply here also.
</p><p>See <code><a href="Control-Distributed.html#t:Process">Process</a></code>
</p></div></div><div class="top"><p class="src"><a name="v:cancelWait" class="def">cancelWait</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async.html#t:AsyncResult">AsyncResult</a> a)</p><div class="doc"><p>Cancel an asynchronous operation and wait for the cancellation to complete.
 Because of the asynchronous nature of message passing, the instruction to
 cancel will race with the asynchronous worker, so it is <em>entirely possible</em>
 that the <code><a href="Control-Distributed-Process-Platform-Async.html#t:AsyncResult">AsyncResult</a></code> returned will not necessarily be <code><a href="Control-Distributed-Process-Platform-Async.html#v:AsyncCancelled">AsyncCancelled</a></code>. For
 example, the worker may complete its task after this function is called, but
 before the cancellation instruction is acted upon.
</p><p>If you wish to stop an asychronous operation <em>immediately</em> (with caveats)
 then consider using <code><a href="Control-Distributed-Process-Platform-Async.html#v:cancelWith">cancelWith</a></code> or <code><a href="Control-Distributed-Process-Platform-Async.html#v:cancelKill">cancelKill</a></code> instead.
</p></div></div><div class="top"><p class="src"><a name="v:cancelWith" class="def">cancelWith</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b =&gt; b -&gt; <a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html#t:-40--41-">()</a></p><div class="doc"><p>Cancel an asynchronous operation immediately.
 This operation is performed by sending an <em>exit signal</em> to the asynchronous
 worker, which leads to the following semantics:
</p><ol><li> If the worker already completed, this function has no effect.
</li><li> The worker might complete after this call, but before the signal arrives.
</li><li> The worker might ignore the exit signal using <code>catchExit</code>.
</li></ol><p>In case of (3), this function has no effect. You should use <code><a href="Control-Distributed-Process-Platform-Async.html#v:cancel">cancel</a></code>
 if you need to guarantee that the asynchronous task is unable to ignore
 the cancellation instruction.
</p><p>You should also consider that when sending exit signals to a process, the
 definition of <code>immediately</code> is somewhat vague and a scheduler might take
 time to handle the request, which can lead to situations similar to (1) as
 listed above, if the scheduler to which the calling process' thread is bound
 decides to GC whilst another scheduler on which the worker is running is able
 to continue.
</p><p>See <code><a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Primitives.html#v:exit">exit</a></code>
</p></div></div><div class="top"><p class="src"><a name="v:cancelKill" class="def">cancelKill</a> ::  <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-String.html#t:String">String</a> -&gt; <a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html#t:-40--41-">()</a></p><div class="doc"><p>Like <code><a href="Control-Distributed-Process-Platform-Async.html#v:cancelWith">cancelWith</a></code> but sends a <code>kill</code> instruction instead of an exit signal.
</p><p>See <code><a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Primitives.html#v:kill">kill</a></code>
</p></div></div><h1 id="g:4">Querying for results
</h1><div class="top"><p class="src"><a name="v:poll" class="def">poll</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async.html#t:AsyncResult">AsyncResult</a> a)</p><div class="doc"><p>Check whether an <code><a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a></code> handle has completed yet. The status of the
 action is encoded in the returned <code><a href="Control-Distributed-Process-Platform-Async.html#t:AsyncResult">AsyncResult</a></code>. If the action has not
 completed, the result will be <code><a href="Control-Distributed-Process-Platform-Async.html#v:AsyncPending">AsyncPending</a></code>, or one of the other
 constructors otherwise. This function does not block waiting for the result.
 Use <code><a href="Control-Distributed-Process-Platform-Async.html#v:wait">wait</a></code> or <code><a href="Control-Distributed-Process-Platform-Async.html#v:waitTimeout">waitTimeout</a></code> if you need blocking/waiting semantics.
</p></div></div><div class="top"><p class="src"><a name="v:check" class="def">check</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Control-Distributed-Process-Platform-Async.html#t:AsyncResult">AsyncResult</a> a))</p><div class="doc"><p>Like <code><a href="Control-Distributed-Process-Platform-Async.html#v:poll">poll</a></code> but returns <code><a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Maybe.html#v:Nothing">Nothing</a></code> if <code>(poll hAsync) == AsyncPending</code>.
 See <code><a href="Control-Distributed-Process-Platform-Async.html#v:poll">poll</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:wait" class="def">wait</a> ::  <a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async.html#t:AsyncResult">AsyncResult</a> a)</p><div class="doc"><p>Wait for an asynchronous action to complete, and return its
 value. The result (which can include failure and/or cancellation) is
 encoded by the <code><a href="Control-Distributed-Process-Platform-Async.html#t:AsyncResult">AsyncResult</a></code> type.
</p></div></div><h1 id="g:5">Waiting with timeouts
</h1><div class="top"><p class="src"><a name="v:waitTimeout" class="def">waitTimeout</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; <a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Maybe.html#t:Maybe">Maybe</a> (<a href="Control-Distributed-Process-Platform-Async.html#t:AsyncResult">AsyncResult</a> a))</p><div class="doc"><p>Wait for an asynchronous operation to complete or timeout. Returns
 <code>Nothing</code> if the <code><a href="Control-Distributed-Process-Platform-Async.html#t:AsyncResult">AsyncResult</a></code> does not change from <code>AsyncPending</code> within
 the specified delay, otherwise <code>Just asyncResult</code> is returned. If you want
 to wait/block on the <code><a href="Control-Distributed-Process-Platform-Async.html#t:AsyncResult">AsyncResult</a></code> without the indirection of <code>Maybe</code> then
 consider using <code><a href="Control-Distributed-Process-Platform-Async.html#v:wait">wait</a></code> or <code><a href="Control-Distributed-Process-Platform-Async.html#v:waitCheckTimeout">waitCheckTimeout</a></code> instead.
</p></div></div><div class="top"><p class="src"><a name="v:waitCancelTimeout" class="def">waitCancelTimeout</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; <a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async.html#t:AsyncResult">AsyncResult</a> a)</p><div class="doc"><p>Wait for an asynchronous operation to complete or timeout. If it times out,
 then <code><a href="Control-Distributed-Process-Platform-Async.html#v:cancelWait">cancelWait</a></code> the async handle instead.
</p></div></div><div class="top"><p class="src"><a name="v:waitCheckTimeout" class="def">waitCheckTimeout</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; <a href="Control-Distributed-Process-Platform-Async.html#t:Async">Async</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async.html#t:AsyncResult">AsyncResult</a> a)</p><div class="doc"><p>Wait for an asynchronous operation to complete or timeout. This variant
 returns the <code><a href="Control-Distributed-Process-Platform-Async.html#t:AsyncResult">AsyncResult</a></code> itself, which will be <code><a href="Control-Distributed-Process-Platform-Async.html#v:AsyncPending">AsyncPending</a></code> if the
 result has not been made available, otherwise one of the other constructors.
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.11.0</p></div></body></html>