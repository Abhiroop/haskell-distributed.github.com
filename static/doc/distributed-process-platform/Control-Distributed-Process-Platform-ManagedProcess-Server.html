<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Control.Distributed.Process.Platform.ManagedProcess.Server</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Control-Distributed-Process-Platform-ManagedProcess-Server.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">distributed-process-platform-0.1.0: The Cloud Haskell Application Platform</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Control.Distributed.Process.Platform.ManagedProcess.Server</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Server actions
</a></li><li><a href="#g:2">Server handler/callback creation
</a></li><li><a href="#g:3">Stateless handlers
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Server process API
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:condition">condition</a> :: <span class="keyword">forall</span> a b. (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; (a -&gt; b -&gt; <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; Condition a b</li><li class="src short"><a href="#v:state">state</a> :: <span class="keyword">forall</span> s m. <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> m =&gt; (s -&gt; <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; Condition s m</li><li class="src short"><a href="#v:input">input</a> :: <span class="keyword">forall</span> s m. <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> m =&gt; (m -&gt; <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; Condition s m</li><li class="src short"><a href="#v:reply">reply</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> r =&gt; r -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s r)</li><li class="src short"><a href="#v:replyWith">replyWith</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> m =&gt; m -&gt; <a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s m)</li><li class="src short"><a href="#v:noReply">noReply</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> r =&gt; <a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s r)</li><li class="src short"><a href="#v:noReply_">noReply_</a> :: <span class="keyword">forall</span> s r. <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> r =&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s r)</li><li class="src short"><a href="#v:haltNoReply_">haltNoReply_</a> ::  <a href="Control-Distributed-Process-Platform.html#t:TerminateReason">TerminateReason</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s <a href="Control-Distributed-Process-Platform.html#t:TerminateReason">TerminateReason</a>)</li><li class="src short"><a href="#v:continue">continue</a> ::  s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</li><li class="src short"><a href="#v:continue_">continue_</a> ::  s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</li><li class="src short"><a href="#v:timeoutAfter">timeoutAfter</a> ::  <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</li><li class="src short"><a href="#v:timeoutAfter_">timeoutAfter_</a> ::  <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</li><li class="src short"><a href="#v:hibernate">hibernate</a> ::  <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</li><li class="src short"><a href="#v:hibernate_">hibernate_</a> ::  <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</li><li class="src short"><a href="#v:stop">stop</a> ::  <a href="Control-Distributed-Process-Platform.html#t:TerminateReason">TerminateReason</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</li><li class="src short"><a href="#v:stop_">stop_</a> ::  <a href="Control-Distributed-Process-Platform.html#t:TerminateReason">TerminateReason</a> -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</li><li class="src short"><a href="#v:replyTo">replyTo</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> m =&gt; <a href="Control-Distributed-Process-Platform.html#t:Recipient">Recipient</a> -&gt; m -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html#t:-40--41-">()</a></li><li class="src short"><a href="#v:handleCall">handleCall</a> :: (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; (s -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s b)) -&gt; Dispatcher s</li><li class="src short"><a href="#v:handleCallIf">handleCallIf</a> :: <span class="keyword">forall</span> s a b. (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; Condition s a -&gt; (s -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s b)) -&gt; Dispatcher s</li><li class="src short"><a href="#v:handleCallFrom">handleCallFrom</a> :: <span class="keyword">forall</span> s a b. (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; (s -&gt; <a href="Control-Distributed-Process-Platform.html#t:Recipient">Recipient</a> -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s b)) -&gt; Dispatcher s</li><li class="src short"><a href="#v:handleCallFromIf">handleCallFromIf</a> :: <span class="keyword">forall</span> s a b. (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; Condition s a -&gt; (s -&gt; <a href="Control-Distributed-Process-Platform.html#t:Recipient">Recipient</a> -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s b)) -&gt; Dispatcher s</li><li class="src short"><a href="#v:handleCast">handleCast</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; (s -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)) -&gt; Dispatcher s</li><li class="src short"><a href="#v:handleCastIf">handleCastIf</a> :: <span class="keyword">forall</span> s a. <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; Condition s a -&gt; (s -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)) -&gt; Dispatcher s</li><li class="src short"><a href="#v:handleInfo">handleInfo</a> :: <span class="keyword">forall</span> s a. <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; (s -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)) -&gt; DeferredDispatcher s</li><li class="src short"><a href="#v:handleDispatch">handleDispatch</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; (s -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)) -&gt; Dispatcher s</li><li class="src short"><a href="#v:handleExit">handleExit</a> :: <span class="keyword">forall</span> s a. <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; (s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:ProcessId">ProcessId</a> -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)) -&gt; ExitSignalDispatcher s</li><li class="src short"><a href="#v:action">action</a> :: <span class="keyword">forall</span> s a. <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; (a -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)) -&gt; Dispatcher s</li><li class="src short"><a href="#v:handleCall_">handleCall_</a> :: (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; (a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> b) -&gt; Dispatcher s</li><li class="src short"><a href="#v:handleCallIf_">handleCallIf_</a> :: <span class="keyword">forall</span> s a b. (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; Condition s a -&gt; (a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> b) -&gt; Dispatcher s</li><li class="src short"><a href="#v:handleCast_">handleCast_</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; (a -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)) -&gt; Dispatcher s</li><li class="src short"><a href="#v:handleCastIf_">handleCastIf_</a> :: <span class="keyword">forall</span> s a. <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; Condition s a -&gt; (a -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)) -&gt; Dispatcher s</li></ul></div><div id="interface"><h1 id="g:1">Server actions
</h1><div class="top"><p class="src"><a name="v:condition" class="def">condition</a> :: <span class="keyword">forall</span> a b. (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; (a -&gt; b -&gt; <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; Condition a b</p><div class="doc"><p>Creates a <code>Conditon</code> from a function that takes a process state <code>a</code> and
 an input message <code>b</code> and returns a <code><a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Bool.html#t:Bool">Bool</a></code> indicating whether the associated
 handler should run.
</p></div></div><div class="top"><p class="src"><a name="v:state" class="def">state</a> :: <span class="keyword">forall</span> s m. <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> m =&gt; (s -&gt; <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; Condition s m</p><div class="doc"><p>Create a <code>Condition</code> from a function that takes a process state <code>a</code> and
 returns a <code><a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Bool.html#t:Bool">Bool</a></code> indicating whether the associated handler should run.
</p></div></div><div class="top"><p class="src"><a name="v:input" class="def">input</a> :: <span class="keyword">forall</span> s m. <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> m =&gt; (m -&gt; <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; Condition s m</p><div class="doc"><p>Creates a <code>Condition</code> from a function that takes an input message <code>m</code> and
 returns a <code><a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Bool.html#t:Bool">Bool</a></code> indicating whether the associated handler should run.
</p></div></div><div class="top"><p class="src"><a name="v:reply" class="def">reply</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> r =&gt; r -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s r)</p><div class="doc"><p>Instructs the process to send a reply and continue running.
</p></div></div><div class="top"><p class="src"><a name="v:replyWith" class="def">replyWith</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> m =&gt; m -&gt; <a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s m)</p><div class="doc"><p>Instructs the process to send a reply <em>and</em> evaluate the <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:noReply" class="def">noReply</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> r =&gt; <a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s r)</p><div class="doc"><p>Instructs the process to skip sending a reply <em>and</em> evaluate a <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a></code>
</p></div></div><div class="top"><p class="src"><a name="v:noReply_" class="def">noReply_</a> :: <span class="keyword">forall</span> s r. <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> r =&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s r)</p><div class="doc"><p>Continue without giving a reply to the caller - equivalent to <code><a href="Control-Distributed-Process-Platform-ManagedProcess-Server.html#v:continue">continue</a></code>,
 but usable in a callback passed to the <code><a href="Control-Distributed-Process-Platform-ManagedProcess-Server.html#v:handleCall">handleCall</a></code> family of functions.
</p></div></div><div class="top"><p class="src"><a name="v:haltNoReply_" class="def">haltNoReply_</a> ::  <a href="Control-Distributed-Process-Platform.html#t:TerminateReason">TerminateReason</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s <a href="Control-Distributed-Process-Platform.html#t:TerminateReason">TerminateReason</a>)</p><div class="doc"><p>Halt process execution during a call handler, without paying any attention
 to the expected return type.
</p></div></div><div class="top"><p class="src"><a name="v:continue" class="def">continue</a> ::  s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</p><div class="doc"><p>Instructs the process to continue running and receiving messages.
</p></div></div><div class="top"><p class="src"><a name="v:continue_" class="def">continue_</a> ::  s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</p><div class="doc"><p>Version of <code><a href="Control-Distributed-Process-Platform-ManagedProcess-Server.html#v:continue">continue</a></code> that can be used in handlers that ignore process state.
</p></div></div><div class="top"><p class="src"><a name="v:timeoutAfter" class="def">timeoutAfter</a> ::  <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</p><div class="doc"><p>Instructs the process to wait for incoming messages until <code><a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a></code>
 is exceeded. If no messages are handled during this period, the <em>timeout</em>
 handler will be called. Note that this alters the process timeout permanently
 such that the given <code>TimeInterval</code> will remain in use until changed.
</p></div></div><div class="top"><p class="src"><a name="v:timeoutAfter_" class="def">timeoutAfter_</a> ::  <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</p><div class="doc"><p>Version of <code><a href="Control-Distributed-Process-Platform-ManagedProcess-Server.html#v:timeoutAfter">timeoutAfter</a></code> that can be used in handlers that ignore process state.
</p><pre> action (\(TimeoutPlease duration) -&gt; timeoutAfter_ duration)
</pre></div></div><div class="top"><p class="src"><a name="v:hibernate" class="def">hibernate</a> ::  <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</p><div class="doc"><p>Instructs the process to <em>hibernate</em> for the given <code><a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a></code>. Note
 that no messages will be removed from the mailbox until after hibernation has
 ceased. This is equivalent to calling <code>threadDelay</code>.
</p></div></div><div class="top"><p class="src"><a name="v:hibernate_" class="def">hibernate_</a> ::  <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</p><div class="doc"><p>Version of <code><a href="Control-Distributed-Process-Platform-ManagedProcess-Server.html#v:hibernate">hibernate</a></code> that can be used in handlers that ignore process state.
</p><pre> action (\(HibernatePlease delay) -&gt; hibernate_ delay)
</pre></div></div><div class="top"><p class="src"><a name="v:stop" class="def">stop</a> ::  <a href="Control-Distributed-Process-Platform.html#t:TerminateReason">TerminateReason</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</p><div class="doc"><p>Instructs the process to terminate, giving the supplied reason. If a valid
 <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:terminateHandler">terminateHandler</a></code> is installed, it will be called with the <code><a href="Control-Distributed-Process-Platform.html#t:TerminateReason">TerminateReason</a></code>
 returned from this call, along with the process state.
</p></div></div><div class="top"><p class="src"><a name="v:stop_" class="def">stop_</a> ::  <a href="Control-Distributed-Process-Platform.html#t:TerminateReason">TerminateReason</a> -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</p><div class="doc"><p>Version of <code><a href="Control-Distributed-Process-Platform-ManagedProcess-Server.html#v:stop">stop</a></code> that can be used in handlers that ignore process state.
</p><pre> action (\ClientError -&gt; stop_ TerminateNormal)
</pre></div></div><div class="top"><p class="src"><a name="v:replyTo" class="def">replyTo</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> m =&gt; <a href="Control-Distributed-Process-Platform.html#t:Recipient">Recipient</a> -&gt; m -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html#t:-40--41-">()</a></p></div><h1 id="g:2">Server handler/callback creation
</h1><div class="top"><p class="src"><a name="v:handleCall" class="def">handleCall</a> :: (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; (s -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s b)) -&gt; Dispatcher s</p></div><div class="top"><p class="src"><a name="v:handleCallIf" class="def">handleCallIf</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> s a b . (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Condition s a</td><td class="doc"><p>predicate that must be satisfied for the handler to run
</p></td></tr><tr><td class="src">-&gt; (s -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s b))</td><td class="doc"><p>a reply yielding function over the process state and input message
</p></td></tr><tr><td class="src">-&gt; Dispatcher s</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Constructs a <code>call</code> handler from an ordinary function in the <code><a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a></code>
 monad. Given a function <code>f :: (s -&gt; a -&gt; Process (ProcessReply s b))</code>,
 the expression <code>handleCall f</code> will yield a <code>Dispatcher</code> for inclusion
 in a <code>Behaviour</code> specification for the <em>GenProcess</em>. Messages are only
 dispatched to the handler if the supplied condition evaluates to <code>True</code>
</p></div></div><div class="top"><p class="src"><a name="v:handleCallFrom" class="def">handleCallFrom</a> :: <span class="keyword">forall</span> s a b. (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; (s -&gt; <a href="Control-Distributed-Process-Platform.html#t:Recipient">Recipient</a> -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s b)) -&gt; Dispatcher s</p><div class="doc"><p>As <code><a href="Control-Distributed-Process-Platform-ManagedProcess-Server.html#v:handleCall">handleCall</a></code> but passes the <code><a href="Control-Distributed-Process-Platform.html#t:Recipient">Recipient</a></code> to the handler function.
 This can be useful if you wish to <em>reply later</em> to the caller by, e.g.,
 spawning a process to do some work and have it <code>replyTo caller response</code>
 out of band. In this case the callback can pass the <code><a href="Control-Distributed-Process-Platform.html#t:Recipient">Recipient</a></code> to the
 worker (or stash it away itself) and return <code><a href="Control-Distributed-Process-Platform-ManagedProcess-Server.html#v:noReply">noReply</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:handleCallFromIf" class="def">handleCallFromIf</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> s a b . (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Condition s a</td><td class="doc"><p>predicate that must be satisfied for the handler to run
</p></td></tr><tr><td class="src">-&gt; (s -&gt; <a href="Control-Distributed-Process-Platform.html#t:Recipient">Recipient</a> -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s b))</td><td class="doc"><p>a reply yielding function over the process state, sender and input message
</p></td></tr><tr><td class="src">-&gt; Dispatcher s</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>As <code><a href="Control-Distributed-Process-Platform-ManagedProcess-Server.html#v:handleCallFrom">handleCallFrom</a></code> but only runs the handler if the supplied <code>Condition</code>
 evaluates to <code>True</code>.
</p></div></div><div class="top"><p class="src"><a name="v:handleCast" class="def">handleCast</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; (s -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)) -&gt; Dispatcher s</p></div><div class="top"><p class="src"><a name="v:handleCastIf" class="def">handleCastIf</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> s a . <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Condition s a</td><td class="doc"><p>predicate that must be satisfied for the handler to run
</p></td></tr><tr><td class="src">-&gt; (s -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s))</td><td class="doc"><p>an action yielding function over the process state and input message
</p></td></tr><tr><td class="src">-&gt; Dispatcher s</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Constructs a <code>cast</code> handler from an ordinary function in the <code><a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a></code>
 monad. Given a function <code>f :: (s -&gt; a -&gt; Process (ProcessAction s))</code>,
 the expression <code>handleCall f</code> will yield a <code>Dispatcher</code> for inclusion
 in a <code>Behaviour</code> specification for the <em>GenProcess</em>.
</p></div></div><div class="top"><p class="src"><a name="v:handleInfo" class="def">handleInfo</a> :: <span class="keyword">forall</span> s a. <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; (s -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)) -&gt; DeferredDispatcher s</p><div class="doc"><p>Creates a generic input handler (i.e., for recieved messages that are <em>not</em>
 sent using the <code>cast</code> or <code>call</code> APIs) from an ordinary function in the
 <code><a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a></code> monad.
</p></div></div><div class="top"><p class="src"><a name="v:handleDispatch" class="def">handleDispatch</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; (s -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)) -&gt; Dispatcher s</p><div class="doc"><p>Constructs a handler for both <em>call</em> and <em>cast</em> messages.
 <code>handleDispatch = handleDispatchIf (const True)</code>
</p></div></div><div class="top"><p class="src"><a name="v:handleExit" class="def">handleExit</a> :: <span class="keyword">forall</span> s a. <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; (s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:ProcessId">ProcessId</a> -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)) -&gt; ExitSignalDispatcher s</p><div class="doc"><p>Creates an <em>exit handler</em> scoped to the execution of any and all the
 registered call, cast and info handlers for the process.
</p></div></div><h1 id="g:3">Stateless handlers
</h1><div class="top"><p class="src"><a name="v:action" class="def">action</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> s a . <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (a -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s))</td><td class="doc"><p>a function from the input message to a <em>stateless action</em>, cf <code><a href="Control-Distributed-Process-Platform-ManagedProcess-Server.html#v:continue_">continue_</a></code>
</p></td></tr><tr><td class="src">-&gt; Dispatcher s</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Constructs an <em>action</em> handler. Like <code><a href="Control-Distributed-Process-Platform-ManagedProcess-Server.html#v:handleDispatch">handleDispatch</a></code> this can handle both
 <code>cast</code> and <code>call</code> messages and you won't know which you're dealing with.
 This can be useful where certain inputs require a definite action, such as
 stopping the server, without concern for the state (e.g., when stopping we
 need only decide to stop, as the terminate handler can deal with state
 cleanup etc). For example:
</p><pre>action (MyCriticalErrorSignal -&gt; stop_ TerminateNormal)</pre></div></div><div class="top"><p class="src"><a name="v:handleCall_" class="def">handleCall_</a> :: (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; (a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> b) -&gt; Dispatcher s</p><div class="doc"><p>Constructs a <code>call</code> handler from a function in the <code><a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a></code> monad.
 The handler expression returns the reply, and the action will be
 set to <code><a href="Control-Distributed-Process-Platform-ManagedProcess-Server.html#v:continue">continue</a></code>.
</p><pre> handleCall_ = handleCallIf_ (const True)
</pre></div></div><div class="top"><p class="src"><a name="v:handleCallIf_" class="def">handleCallIf_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> s a b . (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Condition s a</td><td class="doc"><p>predicate that must be satisfied for the handler to run
</p></td></tr><tr><td class="src">-&gt; (a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> b)</td><td class="doc"><p>a function from an input message to a reply
</p></td></tr><tr><td class="src">-&gt; Dispatcher s</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Constructs a <code>call</code> handler from an ordinary function in the <code><a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a></code>
 monad. This variant ignores the state argument present in <code><a href="Control-Distributed-Process-Platform-ManagedProcess-Server.html#v:handleCall">handleCall</a></code> and
 <code><a href="Control-Distributed-Process-Platform-ManagedProcess-Server.html#v:handleCallIf">handleCallIf</a></code> and is therefore useful in a stateless server. Messges are
 only dispatched to the handler if the supplied condition evaluates to <code>True</code>
</p><p>See <code><a href="Control-Distributed-Process-Platform-ManagedProcess-Server.html#v:handleCall">handleCall</a></code>
</p></div></div><div class="top"><p class="src"><a name="v:handleCast_" class="def">handleCast_</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; (a -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)) -&gt; Dispatcher s</p><div class="doc"><p>Version of <code><a href="Control-Distributed-Process-Platform-ManagedProcess-Server.html#v:handleCast">handleCast</a></code> that ignores the server state.
</p></div></div><div class="top"><p class="src"><a name="v:handleCastIf_" class="def">handleCastIf_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> s a . <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Condition s a</td><td class="doc"><p>predicate that must be satisfied for the handler to run
</p></td></tr><tr><td class="src">-&gt; (a -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s))</td><td class="doc"><p>a function from the input message to a <em>stateless action</em>, cf <code><a href="Control-Distributed-Process-Platform-ManagedProcess-Server.html#v:continue_">continue_</a></code>
</p></td></tr><tr><td class="src">-&gt; Dispatcher s</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Version of <code><a href="Control-Distributed-Process-Platform-ManagedProcess-Server.html#v:handleCastIf">handleCastIf</a></code> that ignores the server state.
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.11.0</p></div></body></html>