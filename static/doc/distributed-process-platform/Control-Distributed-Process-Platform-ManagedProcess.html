<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Control.Distributed.Process.Platform.ManagedProcess</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Control-Distributed-Process-Platform-ManagedProcess.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">distributed-process-platform-0.1.0: The Cloud Haskell Application Platform</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Portability</th><td>non-portable (requires concurrency)</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Maintainer</th><td>Tim Watson &lt;watson.timothy@gmail.com&gt;</td></tr><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Control.Distributed.Process.Platform.ManagedProcess</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Starting server processes
</a></li><li><a href="#g:2">Client interactions
</a></li><li><a href="#g:3">Defining server processes
</a></li><li><a href="#g:4">Stateless handlers
</a></li><li><a href="#g:5">Constructing handler results
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module provides a high(er) level API for building complex <code><a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a></code>
 implementations by abstracting out the management of the process' mailbox,
 reply/response handling, timeouts, process hiberation, error handling
 and shutdown/stop procedures. It is modelled along similar lines to OTP's
 gen_server API - <a href="http://www.erlang.org/doc/man/gen_server.html">http://www.erlang.org/doc/man/gen_server.html</a>.
</p><dl><dt>API Overview</dt><dd>
</dd></dl><p>Once started, a generic process will consume messages from its mailbox and
 pass them on to user defined <em>handlers</em> based on the types received (mapped
 to those accepted by the handlers) and optionally by also evaluating user
 supplied predicates to determine which handlers are valid.
 Each handler returns a <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a></code> which specifies how we should proceed.
 If none of the handlers is able to process a message (because their types are
 incompatible) then the process <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:unhandledMessagePolicy">unhandledMessagePolicy</a></code> will be applied.
</p><p>The <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a></code> type defines the ways in which a process can respond
 to its inputs, either by continuing to read incoming messages, setting an
 optional timeout, sleeping for a while or by stopping. The optional timeout
 behaves a little differently to the other process actions. If no messages
 are received within the specified time span, the process <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:timeoutHandler">timeoutHandler</a></code>
 will be called in order to determine the next action.
</p><p>Generic processes are defined by the <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessDefinition">ProcessDefinition</a></code> type, using record
 syntax. The <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessDefinition">ProcessDefinition</a></code> fields contain handlers (or lists of them)
 for specific tasks. In addtion to the <code>timeoutHandler</code>, a <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessDefinition">ProcessDefinition</a></code>
 may also define a <code>terminateHandler</code> which is called just before the process
 exits. This handler will be called <em>whenever</em> the process is stopping, i.e.,
 when a callback returns <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:stop">stop</a></code> as the next action <em>or</em> if an unhandled exit
 signal or similar asynchronous exception is thrown in (or to) the process
 itself.
</p><p>The other handlers are split into two groups: <em>apiHandlers</em> and <em>infoHandlers</em>.
 The former contains handlers for the <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:cast">cast</a></code> and <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:call">call</a></code> protocols, whilst the
 latter contains handlers that deal with input messages which are not sent
 via these API calls (i.e., messages sent using bare <code><a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Primitives.html#v:send">send</a></code> or signals put
 into the process mailbox by the node controller, such as
 <code><a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:ProcessMonitorNotification">ProcessMonitorNotification</a></code> and the like).
</p><dl><dt>The Cast/Call Protocol</dt><dd>
</dd></dl><p>Deliberate interactions with the process will usually fall into one of two
 categories. A <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:cast">cast</a></code> interaction involves a client sending a message
 asynchronously and the server handling this input. No reply is sent to
 the client. On the other hand, a <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:call">call</a></code> interaction is a kind of <em>rpc</em>
 where the client sends a message and waits for a reply.
</p><p>The expressions given to <code>apiHandlers</code> have to conform to the <em>cast|call</em>
 protocol. The details of this are, however, hidden from the user. A set
 of API functions for creating <code>apiHandlers</code> are given instead, which
 take expressions (i.e., a function or lambda expression) and create the
 appropriate <code>Dispatcher</code> for handling the cast (or call).
</p><p>The cast<em>call protocol handlers deal with </em>expected/ inputs. These form
 the explicit public API for the process, and will usually be exposed by
 providing module level functions that defer to the cast/call API. For
 example:
</p><pre>
 add :: ProcessId -&gt; Double -&gt; Double -&gt; Double
 add pid x y = call pid (Add x y)
</pre><dl><dt>Handling Info Messages</dt><dd>
</dd></dl><p>An explicit protocol for communicating with the process can be
 configured using <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:cast">cast</a></code> and <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:call">call</a></code>, but it is not possible to prevent
 other kinds of messages from being sent to the process mailbox. When
 any message arrives for which there are no handlers able to process
 its content, the <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:UnhandledMessagePolicy">UnhandledMessagePolicy</a></code> will be applied. Sometimes
 it is desireable to process incoming messages which aren't part of the
 protocol, rather than let the policy deal with them. This is particularly
 true when incoming messages are important to the process, but their point
 of origin is outside the developer's control. Handling <em>signals</em> such as
 <code><a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:ProcessMonitorNotification">ProcessMonitorNotification</a></code> is a typical example of this:
</p><pre> handleInfo_ (\(ProcessMonitorNotification _ _ r) -&gt; say $ show r &gt;&gt; continue_)
</pre><dl><dt>Handling Process State</dt><dd>
</dd></dl><p>The <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessDefinition">ProcessDefinition</a></code> is parameterised by the type of state it maintains.
 A process that has no state will have the type <code>ProcessDefinition ()</code> and can
 be bootstrapped by evaluating <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:statelessProcess">statelessProcess</a></code>.
</p><p>All call/cast handlers come in two flavours, those which take the process
 state as an input and those which do not. Handlers that ignore the process
 state have to return a function that takes the state and returns the required
 action. Versions of the various action generating functions ending in an
 underscore are provided to simplify this:
</p><pre>
   statelessProcess {
       apiHandlers = [
         handleCall_   (\(n :: Int) -&gt; return (n * 2))
       , handleCastIf_ (\(c :: String, _ :: Delay) -&gt; c == &quot;timeout&quot;)
                       (\(&quot;timeout&quot;, Delay d) -&gt; timeoutAfter_ d)
       ]
     , timeoutHandler = \_ _ -&gt; stop $ TerminateOther &quot;timeout&quot;
   }
</pre><dl><dt>Handling Errors</dt><dd>
</dd></dl><p>Error handling appears in several contexts and process definitions can
 hook into these with relative ease. Only process failures as a result of
 asynchronous exceptions are supported by the API, which provides several
 scopes for error handling.
</p><p>Catching exceptions inside handler functions is no different to ordinary
 exception handling in monadic code.
</p><pre>
   handleCall (\x y -&gt;
                catch (hereBeDragons x y)
                      (\(e :: SmaugTheTerribleException) -&gt;
                           return (Left (show e))))
</pre><p>The caveats mentioned in <a href="Control-Distributed-Process-Platform.html">Control.Distributed.Process.Platform</a> about
 exit signal handling obviously apply here as well.
</p><dl><dt>Structured Exit Signal Handling</dt><dd>
</dd></dl><p>Because <a href="Control-Distributed-Process-ProcessExitException.html">Control.Distributed.Process.ProcessExitException</a> is a ubiquitous
 <em>signalling mechanism</em> in Cloud Haskell, it is treated unlike other
 asynchronous exceptions. The <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessDefinition">ProcessDefinition</a></code> <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:exitHandlers">exitHandlers</a></code> field
 accepts a list of handlers that, for a specific exit reason, can decide
 how the process should respond. If none of these handlers matches the
 type of <code>reason</code> then the process will exit with <code>DiedException why</code>. In
 addition, a default <em>exit handler</em> is installed for exit signals where the
 <code>reason == Shutdown</code>, because this is an <em>exit signal</em> used explicitly and
 extensively throughout the platform. The default behaviour is to gracefully
 shut down the process, calling the <code>terminateHandler</code> as usual, before
 stopping with <code>TerminateShutdown</code> given as the final outcome.
</p><p><em>Example: How to annoy your supervisor and end up force-killed:</em>
</p><pre> handleExit  (\state from (sigExit :: Shutdown) -&gt; continue s)
</pre><p>That code is, of course, very silly. Under some circumstances, handling
 exit signals is perfectly legitimate. Handling of <em>other</em> forms of
 asynchronous exception is not supported by this API.
</p><p>If any asynchronous exception goes unhandled, the process will immediately
 exit without running the <code>terminateHandler</code>. It is very important to note
 that in Cloud Haskell, link failures generate asynchronous exceptions in
 the target and these will NOT be caught by the API and will therefore
 cause the process to exit <em>without running the termination handler</em>
 callback. If your termination handler is set up to do important work
 (such as resource cleanup) then you should avoid linking you process
 and use monitors instead.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span>  <a href="#t:InitResult">InitResult</a> s<ul class="subs"><li>= <a href="#v:InitOk">InitOk</a> s <a href="Control-Distributed-Process-Platform-Time.html#t:Delay">Delay</a>  </li><li>| <span class="keyword">forall</span> r . <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> r =&gt; <a href="#v:InitFail">InitFail</a> r  </li></ul></li><li class="src short"><span class="keyword">type</span> <a href="#t:InitHandler">InitHandler</a> a s = a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:InitResult">InitResult</a> s)</li><li class="src short"><a href="#v:start">start</a> ::  a -&gt; <a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:InitHandler">InitHandler</a> a s -&gt; <a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessDefinition">ProcessDefinition</a> s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Either.html#t:Either">Either</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:InitResult">InitResult</a> s) <a href="Control-Distributed-Process-Platform.html#t:TerminateReason">TerminateReason</a>)</li><li class="src short"><a href="#v:runProcess">runProcess</a> ::  (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessDefinition">ProcessDefinition</a> s -&gt; s -&gt; <a href="Control-Distributed-Process-Platform-Time.html#t:Delay">Delay</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> <a href="Control-Distributed-Process-Platform.html#t:TerminateReason">TerminateReason</a>) -&gt; a -&gt; <a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:InitHandler">InitHandler</a> a s -&gt; <a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessDefinition">ProcessDefinition</a> s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Either.html#t:Either">Either</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:InitResult">InitResult</a> s) <a href="Control-Distributed-Process-Platform.html#t:TerminateReason">TerminateReason</a>)</li><li class="src short"><a href="#v:shutdown">shutdown</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:ProcessId">ProcessId</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html#t:-40--41-">()</a></li><li class="src short"><a href="#v:defaultProcess">defaultProcess</a> ::  <a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessDefinition">ProcessDefinition</a> s</li><li class="src short"><a href="#v:statelessProcess">statelessProcess</a> :: <a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessDefinition">ProcessDefinition</a> <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html#t:-40--41-">()</a></li><li class="src short"><a href="#v:statelessInit">statelessInit</a> :: <a href="Control-Distributed-Process-Platform-Time.html#t:Delay">Delay</a> -&gt; <a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:InitHandler">InitHandler</a> <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html#t:-40--41-">()</a> <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html#t:-40--41-">()</a></li><li class="src short"><a href="#v:call">call</a> :: <span class="keyword">forall</span> a b. (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:ProcessId">ProcessId</a> -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> b</li><li class="src short"><a href="#v:safeCall">safeCall</a> :: <span class="keyword">forall</span> a b. (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:ProcessId">ProcessId</a> -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Either.html#t:Either">Either</a> <a href="Control-Distributed-Process-Platform.html#t:TerminateReason">TerminateReason</a> b)</li><li class="src short"><a href="#v:tryCall">tryCall</a> :: <span class="keyword">forall</span> s a b. (<a href="Control-Distributed-Process-Platform.html#t:Addressable">Addressable</a> s, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; s -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Maybe.html#t:Maybe">Maybe</a> b)</li><li class="src short"><a href="#v:callAsync">callAsync</a> :: <span class="keyword">forall</span> s a b. (<a href="Control-Distributed-Process-Platform.html#t:Addressable">Addressable</a> s, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; s -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncSTM.html#t:Async">Async</a> b)</li><li class="src short"><a href="#v:callTimeout">callTimeout</a> :: <span class="keyword">forall</span> s a b. (<a href="Control-Distributed-Process-Platform.html#t:Addressable">Addressable</a> s, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; s -&gt; a -&gt; <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Maybe.html#t:Maybe">Maybe</a> b)</li><li class="src short"><a href="#v:cast">cast</a> :: <span class="keyword">forall</span> a m. (<a href="Control-Distributed-Process-Platform.html#t:Addressable">Addressable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> m) =&gt; a -&gt; m -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html#t:-40--41-">()</a></li><li class="src short"><span class="keyword">data</span>  <a href="#t:ProcessDefinition">ProcessDefinition</a> s = <a href="#v:ProcessDefinition">ProcessDefinition</a> {<ul class="subs"><li><a href="#v:apiHandlers">apiHandlers</a> :: [Dispatcher s]</li><li><a href="#v:infoHandlers">infoHandlers</a> :: [DeferredDispatcher s]</li><li><a href="#v:exitHandlers">exitHandlers</a> :: [ExitSignalDispatcher s]</li><li><a href="#v:timeoutHandler">timeoutHandler</a> :: <a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:TimeoutHandler">TimeoutHandler</a> s</li><li><a href="#v:terminateHandler">terminateHandler</a> :: <a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:TerminateHandler">TerminateHandler</a> s</li><li><a href="#v:unhandledMessagePolicy">unhandledMessagePolicy</a> :: <a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:UnhandledMessagePolicy">UnhandledMessagePolicy</a></li></ul>}</li><li class="src short"><span class="keyword">type</span> <a href="#t:TerminateHandler">TerminateHandler</a> s = s -&gt; <a href="Control-Distributed-Process-Platform.html#t:TerminateReason">TerminateReason</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html#t:-40--41-">()</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:TimeoutHandler">TimeoutHandler</a> s = s -&gt; <a href="Control-Distributed-Process-Platform-Time.html#t:Delay">Delay</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</li><li class="src short"><span class="keyword">data</span>  <a href="#t:ProcessAction">ProcessAction</a> s<ul class="subs"><li>= <a href="#v:ProcessContinue">ProcessContinue</a> s  </li><li>| <a href="#v:ProcessTimeout">ProcessTimeout</a> <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> s  </li><li>| <a href="#v:ProcessHibernate">ProcessHibernate</a> <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> s  </li><li>| <a href="#v:ProcessStop">ProcessStop</a> <a href="Control-Distributed-Process-Platform.html#t:TerminateReason">TerminateReason</a>  </li></ul></li><li class="src short"><span class="keyword">data</span>  <a href="#t:ProcessReply">ProcessReply</a> s a</li><li class="src short"><span class="keyword">type</span> <a href="#t:CallHandler">CallHandler</a> a s = s -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s a)</li><li class="src short"><span class="keyword">type</span> <a href="#t:CastHandler">CastHandler</a> s = s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html#t:-40--41-">()</a></li><li class="src short"><span class="keyword">data</span>  <a href="#t:UnhandledMessagePolicy">UnhandledMessagePolicy</a> <ul class="subs"><li>= <a href="#v:Terminate">Terminate</a>  </li><li>| <a href="#v:DeadLetter">DeadLetter</a> <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:ProcessId">ProcessId</a>  </li><li>| <a href="#v:Drop">Drop</a>  </li></ul></li><li class="src short"><a href="#v:handleCall">handleCall</a> :: (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; (s -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s b)) -&gt; Dispatcher s</li><li class="src short"><a href="#v:handleCallIf">handleCallIf</a> :: <span class="keyword">forall</span> s a b. (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; Condition s a -&gt; (s -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s b)) -&gt; Dispatcher s</li><li class="src short"><a href="#v:handleCallFrom">handleCallFrom</a> :: <span class="keyword">forall</span> s a b. (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; (s -&gt; <a href="Control-Distributed-Process-Platform.html#t:Recipient">Recipient</a> -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s b)) -&gt; Dispatcher s</li><li class="src short"><a href="#v:handleCallFromIf">handleCallFromIf</a> :: <span class="keyword">forall</span> s a b. (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; Condition s a -&gt; (s -&gt; <a href="Control-Distributed-Process-Platform.html#t:Recipient">Recipient</a> -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s b)) -&gt; Dispatcher s</li><li class="src short"><a href="#v:handleCast">handleCast</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; (s -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)) -&gt; Dispatcher s</li><li class="src short"><a href="#v:handleCastIf">handleCastIf</a> :: <span class="keyword">forall</span> s a. <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; Condition s a -&gt; (s -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)) -&gt; Dispatcher s</li><li class="src short"><a href="#v:handleInfo">handleInfo</a> :: <span class="keyword">forall</span> s a. <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; (s -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)) -&gt; DeferredDispatcher s</li><li class="src short"><a href="#v:handleDispatch">handleDispatch</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; (s -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)) -&gt; Dispatcher s</li><li class="src short"><a href="#v:handleExit">handleExit</a> :: <span class="keyword">forall</span> s a. <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; (s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:ProcessId">ProcessId</a> -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)) -&gt; ExitSignalDispatcher s</li><li class="src short"><a href="#v:action">action</a> :: <span class="keyword">forall</span> s a. <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; (a -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)) -&gt; Dispatcher s</li><li class="src short"><a href="#v:handleCall_">handleCall_</a> :: (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; (a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> b) -&gt; Dispatcher s</li><li class="src short"><a href="#v:handleCallIf_">handleCallIf_</a> :: <span class="keyword">forall</span> s a b. (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; Condition s a -&gt; (a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> b) -&gt; Dispatcher s</li><li class="src short"><a href="#v:handleCast_">handleCast_</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; (a -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)) -&gt; Dispatcher s</li><li class="src short"><a href="#v:handleCastIf_">handleCastIf_</a> :: <span class="keyword">forall</span> s a. <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; Condition s a -&gt; (a -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)) -&gt; Dispatcher s</li><li class="src short"><a href="#v:condition">condition</a> :: <span class="keyword">forall</span> a b. (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; (a -&gt; b -&gt; <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; Condition a b</li><li class="src short"><a href="#v:state">state</a> :: <span class="keyword">forall</span> s m. <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> m =&gt; (s -&gt; <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; Condition s m</li><li class="src short"><a href="#v:input">input</a> :: <span class="keyword">forall</span> s m. <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> m =&gt; (m -&gt; <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; Condition s m</li><li class="src short"><a href="#v:reply">reply</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> r =&gt; r -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s r)</li><li class="src short"><a href="#v:replyWith">replyWith</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> m =&gt; m -&gt; <a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s m)</li><li class="src short"><a href="#v:noReply">noReply</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> r =&gt; <a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s r)</li><li class="src short"><a href="#v:noReply_">noReply_</a> :: <span class="keyword">forall</span> s r. <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> r =&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s r)</li><li class="src short"><a href="#v:haltNoReply_">haltNoReply_</a> ::  <a href="Control-Distributed-Process-Platform.html#t:TerminateReason">TerminateReason</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s <a href="Control-Distributed-Process-Platform.html#t:TerminateReason">TerminateReason</a>)</li><li class="src short"><a href="#v:continue">continue</a> ::  s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</li><li class="src short"><a href="#v:continue_">continue_</a> ::  s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</li><li class="src short"><a href="#v:timeoutAfter">timeoutAfter</a> ::  <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</li><li class="src short"><a href="#v:timeoutAfter_">timeoutAfter_</a> ::  <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</li><li class="src short"><a href="#v:hibernate">hibernate</a> ::  <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</li><li class="src short"><a href="#v:hibernate_">hibernate_</a> ::  <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</li><li class="src short"><a href="#v:stop">stop</a> ::  <a href="Control-Distributed-Process-Platform.html#t:TerminateReason">TerminateReason</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</li><li class="src short"><a href="#v:stop_">stop_</a> ::  <a href="Control-Distributed-Process-Platform.html#t:TerminateReason">TerminateReason</a> -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</li><li class="src short"><a href="#v:replyTo">replyTo</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> m =&gt; <a href="Control-Distributed-Process-Platform.html#t:Recipient">Recipient</a> -&gt; m -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html#t:-40--41-">()</a></li></ul></div><div id="interface"><h1 id="g:1">Starting server processes
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:InitResult" class="def">InitResult</a> s </p><div class="doc"><p>Return type for and <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:InitHandler">InitHandler</a></code> expression.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:InitOk" class="def">InitOk</a> s <a href="Control-Distributed-Process-Platform-Time.html#t:Delay">Delay</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><span class="keyword">forall</span> r . <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> r =&gt; <a name="v:InitFail" class="def">InitFail</a> r</td><td class="doc"><p>denotes failed initialisation and the reason
</p></td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:InitHandler" class="def">InitHandler</a> a s = a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:InitResult">InitResult</a> s)</p><div class="doc"><p>An expression used to initialise a process with its state.
</p></div></div><div class="top"><p class="src"><a name="v:start" class="def">start</a> ::  a -&gt; <a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:InitHandler">InitHandler</a> a s -&gt; <a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessDefinition">ProcessDefinition</a> s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Either.html#t:Either">Either</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:InitResult">InitResult</a> s) <a href="Control-Distributed-Process-Platform.html#t:TerminateReason">TerminateReason</a>)</p><div class="doc"><p>Starts a gen-process configured with the supplied process definition,
 using an init handler and its initial arguments. This code will run the
 <code><a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a></code> until completion and return <code>Right TerminateReason</code> *or*,
 if initialisation fails, return <code>Left InitResult</code> which will be
 <code>InitFail why</code>.
</p></div></div><div class="top"><p class="src"><a name="v:runProcess" class="def">runProcess</a> ::  (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessDefinition">ProcessDefinition</a> s -&gt; s -&gt; <a href="Control-Distributed-Process-Platform-Time.html#t:Delay">Delay</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> <a href="Control-Distributed-Process-Platform.html#t:TerminateReason">TerminateReason</a>) -&gt; a -&gt; <a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:InitHandler">InitHandler</a> a s -&gt; <a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessDefinition">ProcessDefinition</a> s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Either.html#t:Either">Either</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:InitResult">InitResult</a> s) <a href="Control-Distributed-Process-Platform.html#t:TerminateReason">TerminateReason</a>)</p></div><h1 id="g:2">Client interactions
</h1><div class="top"><p class="src"><a name="v:shutdown" class="def">shutdown</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:ProcessId">ProcessId</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html#t:-40--41-">()</a></p><div class="doc"><p>Send a signal instructing the process to terminate. The <em>receive loop</em> which
 manages the process mailbox will prioritise <code>Shutdown</code> signals higher than
 any other incoming messages, but the server might be busy (i.e., still in the
 process of excuting a handler) at the time of sending however, so the caller
 should not make any assumptions about the timeliness with which the shutdown
 signal will be handled. If responsiveness is important, a better approach
 might be to send an <em>exit signal</em> with <code>Shutdown</code> as the reason. An exit
 signal will interrupt any operation currently underway and force the running
 process to clean up and terminate.
</p></div></div><div class="top"><p class="src"><a name="v:defaultProcess" class="def">defaultProcess</a> ::  <a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessDefinition">ProcessDefinition</a> s</p></div><div class="top"><p class="src"><a name="v:statelessProcess" class="def">statelessProcess</a> :: <a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessDefinition">ProcessDefinition</a> <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html#t:-40--41-">()</a></p><div class="doc"><p>A basic, stateless process definition, where the unhandled message policy
 is set to <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:Terminate">Terminate</a></code>, the default timeout handlers does nothing (i.e., the
 same as calling <code>continue ()</code> and the terminate handler is a no-op.
</p></div></div><div class="top"><p class="src"><a name="v:statelessInit" class="def">statelessInit</a> :: <a href="Control-Distributed-Process-Platform-Time.html#t:Delay">Delay</a> -&gt; <a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:InitHandler">InitHandler</a> <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html#t:-40--41-">()</a> <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html#t:-40--41-">()</a></p><div class="doc"><p>A basic, state <em>unaware</em> <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:InitHandler">InitHandler</a></code> that can be used with
 <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:statelessProcess">statelessProcess</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:call" class="def">call</a> :: <span class="keyword">forall</span> a b. (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:ProcessId">ProcessId</a> -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> b</p><div class="doc"><p>Make a synchronous call - will block until a reply is received.
 The calling process will exit with <code><a href="Control-Distributed-Process-Platform.html#t:TerminateReason">TerminateReason</a></code> if the calls fails.
</p></div></div><div class="top"><p class="src"><a name="v:safeCall" class="def">safeCall</a> :: <span class="keyword">forall</span> a b. (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:ProcessId">ProcessId</a> -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Either.html#t:Either">Either</a> <a href="Control-Distributed-Process-Platform.html#t:TerminateReason">TerminateReason</a> b)</p><div class="doc"><p>Safe version of <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:call">call</a></code> that returns information about the error
 if the operation fails. If an error occurs then the explanation will be
 will be stashed away as <code>(TerminateOther String)</code>.
</p></div></div><div class="top"><p class="src"><a name="v:tryCall" class="def">tryCall</a> :: <span class="keyword">forall</span> s a b. (<a href="Control-Distributed-Process-Platform.html#t:Addressable">Addressable</a> s, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; s -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Maybe.html#t:Maybe">Maybe</a> b)</p><div class="doc"><p>Version of <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:safeCall">safeCall</a></code> that returns <code><a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Maybe.html#v:Nothing">Nothing</a></code> if the operation fails. If
 you need information about *why* a call has failed then you should use
 <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:safeCall">safeCall</a></code> or combine <code>catchExit</code> and <code>call</code> instead.
</p></div></div><div class="top"><p class="src"><a name="v:callAsync" class="def">callAsync</a> :: <span class="keyword">forall</span> s a b. (<a href="Control-Distributed-Process-Platform.html#t:Addressable">Addressable</a> s, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; s -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-Async-AsyncSTM.html#t:Async">Async</a> b)</p><div class="doc"><p>Performs a synchronous <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:call">call</a></code> to the the given server address, however the
 call is made <em>out of band</em> and an async handle is returned immediately. This
 can be passed to functions in the <em>Async</em> API in order to obtain the result.
</p><p>See <a href="Control-Distributed-Process-Platform-Async.html">Control.Distributed.Process.Platform.Async</a>
</p></div></div><div class="top"><p class="src"><a name="v:callTimeout" class="def">callTimeout</a> :: <span class="keyword">forall</span> s a b. (<a href="Control-Distributed-Process-Platform.html#t:Addressable">Addressable</a> s, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; s -&gt; a -&gt; <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Maybe.html#t:Maybe">Maybe</a> b)</p><div class="doc"><p>Make a synchronous call, but timeout and return <code>Nothing</code> if the reply
 is not received within the specified time interval.
</p><p>If the result of the call is a failure (or the call was cancelled) then
 the calling process will exit, with the <code><a href="Control-Distributed-Process-Platform-Async-AsyncSTM.html#t:AsyncResult">AsyncResult</a></code> given as the reason.
</p></div></div><div class="top"><p class="src"><a name="v:cast" class="def">cast</a> :: <span class="keyword">forall</span> a m. (<a href="Control-Distributed-Process-Platform.html#t:Addressable">Addressable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> m) =&gt; a -&gt; m -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html#t:-40--41-">()</a></p><div class="doc"><p>Sends a <em>cast</em> message to the server identified by <code>ServerId</code>. The server
 will not send a response. Like Cloud Haskell's <code><a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Primitives.html#v:send">send</a></code> primitive, cast is
 fully asynchronous and <em>never fails</em> - therefore <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:cast">cast</a></code>ing to a non-existent
 (e.g., dead) server process will not generate an error.
</p></div></div><h1 id="g:3">Defining server processes
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:ProcessDefinition" class="def">ProcessDefinition</a> s </p><div class="doc"><p>Stores the functions that determine runtime behaviour in response to
 incoming messages and a policy for responding to unhandled messages.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:ProcessDefinition" class="def">ProcessDefinition</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:apiHandlers" class="def">apiHandlers</a> :: [Dispatcher s]</dt><dd class="doc"><p>functions that handle call/cast messages
</p></dd><dt class="src"><a name="v:infoHandlers" class="def">infoHandlers</a> :: [DeferredDispatcher s]</dt><dd class="doc"><p>functions that handle non call/cast messages
</p></dd><dt class="src"><a name="v:exitHandlers" class="def">exitHandlers</a> :: [ExitSignalDispatcher s]</dt><dd class="doc"><p>functions that handle exit signals
</p></dd><dt class="src"><a name="v:timeoutHandler" class="def">timeoutHandler</a> :: <a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:TimeoutHandler">TimeoutHandler</a> s</dt><dd class="doc"><p>a function that handles timeouts
</p></dd><dt class="src"><a name="v:terminateHandler" class="def">terminateHandler</a> :: <a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:TerminateHandler">TerminateHandler</a> s</dt><dd class="doc"><p>a function that is run just before the process exits
</p></dd><dt class="src"><a name="v:unhandledMessagePolicy" class="def">unhandledMessagePolicy</a> :: <a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:UnhandledMessagePolicy">UnhandledMessagePolicy</a></dt><dd class="doc"><p>how to deal with unhandled messages
</p></dd></dl><div class="clear"></div></div></td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:TerminateHandler" class="def">TerminateHandler</a> s = s -&gt; <a href="Control-Distributed-Process-Platform.html#t:TerminateReason">TerminateReason</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html#t:-40--41-">()</a></p><div class="doc"><p>An expression used to handle process termination.
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:TimeoutHandler" class="def">TimeoutHandler</a> s = s -&gt; <a href="Control-Distributed-Process-Platform-Time.html#t:Delay">Delay</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</p><div class="doc"><p>An expression used to handle process timeouts.
</p></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:ProcessAction" class="def">ProcessAction</a> s </p><div class="doc"><p>The action taken by a process after a handler has run and its updated state.
 See <code>continue</code>
     <code>timeoutAfter</code>
     <code>hibernate</code>
     <code>stop</code>
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:ProcessContinue" class="def">ProcessContinue</a> s</td><td class="doc"><p>continue with (possibly new) state
</p></td></tr><tr><td class="src"><a name="v:ProcessTimeout" class="def">ProcessTimeout</a> <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> s</td><td class="doc"><p>timeout if no messages are received
</p></td></tr><tr><td class="src"><a name="v:ProcessHibernate" class="def">ProcessHibernate</a> <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> s</td><td class="doc"><p>hibernate for <em>delay</em>
</p></td></tr><tr><td class="src"><a name="v:ProcessStop" class="def">ProcessStop</a> <a href="Control-Distributed-Process-Platform.html#t:TerminateReason">TerminateReason</a></td><td class="doc"><p>stop the process, giving <code>TerminateReason</code>
</p></td></tr></table></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:ProcessReply" class="def">ProcessReply</a> s a </p><div class="doc"><p>Returned from handlers for the synchronous <code><a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process.html#v:call">call</a></code> protocol, encapsulates
 the reply data <em>and</em> the action to take after sending the reply. A handler
 can return <code>NoReply</code> if they wish to ignore the call.
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:CallHandler" class="def">CallHandler</a> a s = s -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s a)</p></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:CastHandler" class="def">CastHandler</a> s = s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html#t:-40--41-">()</a></p></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:UnhandledMessagePolicy" class="def">UnhandledMessagePolicy</a>  </p><div class="doc"><p>Policy for handling unexpected messages, i.e., messages which are not
 sent using the <code><a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process.html#v:call">call</a></code> or <code>cast</code> APIs, and which are not handled by any of the
 <code>handleInfo</code> handlers.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Terminate" class="def">Terminate</a></td><td class="doc"><p>stop immediately, giving <code>TerminateOther <a href="UnhandledInput.html">UnhandledInput</a></code> as the reason
</p></td></tr><tr><td class="src"><a name="v:DeadLetter" class="def">DeadLetter</a> <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:ProcessId">ProcessId</a></td><td class="doc"><p>forward the message to the given recipient
</p></td></tr><tr><td class="src"><a name="v:Drop" class="def">Drop</a></td><td class="doc"><p>dequeue and then drop/ignore the message
</p></td></tr></table></div></div><div class="top"><p class="src"><a name="v:handleCall" class="def">handleCall</a> :: (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; (s -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s b)) -&gt; Dispatcher s</p></div><div class="top"><p class="src"><a name="v:handleCallIf" class="def">handleCallIf</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> s a b . (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Condition s a</td><td class="doc"><p>predicate that must be satisfied for the handler to run
</p></td></tr><tr><td class="src">-&gt; (s -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s b))</td><td class="doc"><p>a reply yielding function over the process state and input message
</p></td></tr><tr><td class="src">-&gt; Dispatcher s</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Constructs a <code>call</code> handler from an ordinary function in the <code><a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a></code>
 monad. Given a function <code>f :: (s -&gt; a -&gt; Process (ProcessReply s b))</code>,
 the expression <code>handleCall f</code> will yield a <code>Dispatcher</code> for inclusion
 in a <code>Behaviour</code> specification for the <em>GenProcess</em>. Messages are only
 dispatched to the handler if the supplied condition evaluates to <code>True</code>
</p></div></div><div class="top"><p class="src"><a name="v:handleCallFrom" class="def">handleCallFrom</a> :: <span class="keyword">forall</span> s a b. (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; (s -&gt; <a href="Control-Distributed-Process-Platform.html#t:Recipient">Recipient</a> -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s b)) -&gt; Dispatcher s</p><div class="doc"><p>As <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:handleCall">handleCall</a></code> but passes the <code><a href="Control-Distributed-Process-Platform.html#t:Recipient">Recipient</a></code> to the handler function.
 This can be useful if you wish to <em>reply later</em> to the caller by, e.g.,
 spawning a process to do some work and have it <code>replyTo caller response</code>
 out of band. In this case the callback can pass the <code><a href="Control-Distributed-Process-Platform.html#t:Recipient">Recipient</a></code> to the
 worker (or stash it away itself) and return <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:noReply">noReply</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:handleCallFromIf" class="def">handleCallFromIf</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> s a b . (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Condition s a</td><td class="doc"><p>predicate that must be satisfied for the handler to run
</p></td></tr><tr><td class="src">-&gt; (s -&gt; <a href="Control-Distributed-Process-Platform.html#t:Recipient">Recipient</a> -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s b))</td><td class="doc"><p>a reply yielding function over the process state, sender and input message
</p></td></tr><tr><td class="src">-&gt; Dispatcher s</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>As <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:handleCallFrom">handleCallFrom</a></code> but only runs the handler if the supplied <code>Condition</code>
 evaluates to <code>True</code>.
</p></div></div><div class="top"><p class="src"><a name="v:handleCast" class="def">handleCast</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; (s -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)) -&gt; Dispatcher s</p></div><div class="top"><p class="src"><a name="v:handleCastIf" class="def">handleCastIf</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> s a . <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Condition s a</td><td class="doc"><p>predicate that must be satisfied for the handler to run
</p></td></tr><tr><td class="src">-&gt; (s -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s))</td><td class="doc"><p>an action yielding function over the process state and input message
</p></td></tr><tr><td class="src">-&gt; Dispatcher s</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Constructs a <code>cast</code> handler from an ordinary function in the <code><a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a></code>
 monad. Given a function <code>f :: (s -&gt; a -&gt; Process (ProcessAction s))</code>,
 the expression <code>handleCall f</code> will yield a <code>Dispatcher</code> for inclusion
 in a <code>Behaviour</code> specification for the <em>GenProcess</em>.
</p></div></div><div class="top"><p class="src"><a name="v:handleInfo" class="def">handleInfo</a> :: <span class="keyword">forall</span> s a. <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; (s -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)) -&gt; DeferredDispatcher s</p><div class="doc"><p>Creates a generic input handler (i.e., for recieved messages that are <em>not</em>
 sent using the <code>cast</code> or <code>call</code> APIs) from an ordinary function in the
 <code><a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a></code> monad.
</p></div></div><div class="top"><p class="src"><a name="v:handleDispatch" class="def">handleDispatch</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; (s -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)) -&gt; Dispatcher s</p><div class="doc"><p>Constructs a handler for both <em>call</em> and <em>cast</em> messages.
 <code>handleDispatch = handleDispatchIf (const True)</code>
</p></div></div><div class="top"><p class="src"><a name="v:handleExit" class="def">handleExit</a> :: <span class="keyword">forall</span> s a. <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; (s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:ProcessId">ProcessId</a> -&gt; a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)) -&gt; ExitSignalDispatcher s</p><div class="doc"><p>Creates an <em>exit handler</em> scoped to the execution of any and all the
 registered call, cast and info handlers for the process.
</p></div></div><h1 id="g:4">Stateless handlers
</h1><div class="top"><p class="src"><a name="v:action" class="def">action</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> s a . <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; (a -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s))</td><td class="doc"><p>a function from the input message to a <em>stateless action</em>, cf <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:continue_">continue_</a></code>
</p></td></tr><tr><td class="src">-&gt; Dispatcher s</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Constructs an <em>action</em> handler. Like <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:handleDispatch">handleDispatch</a></code> this can handle both
 <code>cast</code> and <code>call</code> messages and you won't know which you're dealing with.
 This can be useful where certain inputs require a definite action, such as
 stopping the server, without concern for the state (e.g., when stopping we
 need only decide to stop, as the terminate handler can deal with state
 cleanup etc). For example:
</p><pre>action (MyCriticalErrorSignal -&gt; stop_ TerminateNormal)</pre></div></div><div class="top"><p class="src"><a name="v:handleCall_" class="def">handleCall_</a> :: (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; (a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> b) -&gt; Dispatcher s</p><div class="doc"><p>Constructs a <code>call</code> handler from a function in the <code><a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a></code> monad.
 The handler expression returns the reply, and the action will be
 set to <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:continue">continue</a></code>.
</p><pre> handleCall_ = handleCallIf_ (const True)
</pre></div></div><div class="top"><p class="src"><a name="v:handleCallIf_" class="def">handleCallIf_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> s a b . (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Condition s a</td><td class="doc"><p>predicate that must be satisfied for the handler to run
</p></td></tr><tr><td class="src">-&gt; (a -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> b)</td><td class="doc"><p>a function from an input message to a reply
</p></td></tr><tr><td class="src">-&gt; Dispatcher s</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Constructs a <code>call</code> handler from an ordinary function in the <code><a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a></code>
 monad. This variant ignores the state argument present in <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:handleCall">handleCall</a></code> and
 <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:handleCallIf">handleCallIf</a></code> and is therefore useful in a stateless server. Messges are
 only dispatched to the handler if the supplied condition evaluates to <code>True</code>
</p><p>See <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:handleCall">handleCall</a></code>
</p></div></div><div class="top"><p class="src"><a name="v:handleCast_" class="def">handleCast_</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a =&gt; (a -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)) -&gt; Dispatcher s</p><div class="doc"><p>Version of <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:handleCast">handleCast</a></code> that ignores the server state.
</p></div></div><div class="top"><p class="src"><a name="v:handleCastIf_" class="def">handleCastIf_</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <span class="keyword">forall</span> s a . <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; Condition s a</td><td class="doc"><p>predicate that must be satisfied for the handler to run
</p></td></tr><tr><td class="src">-&gt; (a -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s))</td><td class="doc"><p>a function from the input message to a <em>stateless action</em>, cf <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:continue_">continue_</a></code>
</p></td></tr><tr><td class="src">-&gt; Dispatcher s</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Version of <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:handleCastIf">handleCastIf</a></code> that ignores the server state.
</p></div></div><h1 id="g:5">Constructing handler results
</h1><div class="top"><p class="src"><a name="v:condition" class="def">condition</a> :: <span class="keyword">forall</span> a b. (<a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> a, <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> b) =&gt; (a -&gt; b -&gt; <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; Condition a b</p><div class="doc"><p>Creates a <code>Conditon</code> from a function that takes a process state <code>a</code> and
 an input message <code>b</code> and returns a <code><a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Bool.html#t:Bool">Bool</a></code> indicating whether the associated
 handler should run.
</p></div></div><div class="top"><p class="src"><a name="v:state" class="def">state</a> :: <span class="keyword">forall</span> s m. <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> m =&gt; (s -&gt; <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; Condition s m</p><div class="doc"><p>Create a <code>Condition</code> from a function that takes a process state <code>a</code> and
 returns a <code><a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Bool.html#t:Bool">Bool</a></code> indicating whether the associated handler should run.
</p></div></div><div class="top"><p class="src"><a name="v:input" class="def">input</a> :: <span class="keyword">forall</span> s m. <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> m =&gt; (m -&gt; <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Bool.html#t:Bool">Bool</a>) -&gt; Condition s m</p><div class="doc"><p>Creates a <code>Condition</code> from a function that takes an input message <code>m</code> and
 returns a <code><a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/base-4.5.1.0/Data-Bool.html#t:Bool">Bool</a></code> indicating whether the associated handler should run.
</p></div></div><div class="top"><p class="src"><a name="v:reply" class="def">reply</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> r =&gt; r -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s r)</p><div class="doc"><p>Instructs the process to send a reply and continue running.
</p></div></div><div class="top"><p class="src"><a name="v:replyWith" class="def">replyWith</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> m =&gt; m -&gt; <a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s m)</p><div class="doc"><p>Instructs the process to send a reply <em>and</em> evaluate the <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:noReply" class="def">noReply</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> r =&gt; <a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s r)</p><div class="doc"><p>Instructs the process to skip sending a reply <em>and</em> evaluate a <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a></code>
</p></div></div><div class="top"><p class="src"><a name="v:noReply_" class="def">noReply_</a> :: <span class="keyword">forall</span> s r. <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> r =&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s r)</p><div class="doc"><p>Continue without giving a reply to the caller - equivalent to <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:continue">continue</a></code>,
 but usable in a callback passed to the <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:handleCall">handleCall</a></code> family of functions.
</p></div></div><div class="top"><p class="src"><a name="v:haltNoReply_" class="def">haltNoReply_</a> ::  <a href="Control-Distributed-Process-Platform.html#t:TerminateReason">TerminateReason</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessReply">ProcessReply</a> s <a href="Control-Distributed-Process-Platform.html#t:TerminateReason">TerminateReason</a>)</p><div class="doc"><p>Halt process execution during a call handler, without paying any attention
 to the expected return type.
</p></div></div><div class="top"><p class="src"><a name="v:continue" class="def">continue</a> ::  s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</p><div class="doc"><p>Instructs the process to continue running and receiving messages.
</p></div></div><div class="top"><p class="src"><a name="v:continue_" class="def">continue_</a> ::  s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</p><div class="doc"><p>Version of <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:continue">continue</a></code> that can be used in handlers that ignore process state.
</p></div></div><div class="top"><p class="src"><a name="v:timeoutAfter" class="def">timeoutAfter</a> ::  <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</p><div class="doc"><p>Instructs the process to wait for incoming messages until <code><a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a></code>
 is exceeded. If no messages are handled during this period, the <em>timeout</em>
 handler will be called. Note that this alters the process timeout permanently
 such that the given <code>TimeInterval</code> will remain in use until changed.
</p></div></div><div class="top"><p class="src"><a name="v:timeoutAfter_" class="def">timeoutAfter_</a> ::  <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</p><div class="doc"><p>Version of <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:timeoutAfter">timeoutAfter</a></code> that can be used in handlers that ignore process state.
</p><pre> action (\(TimeoutPlease duration) -&gt; timeoutAfter_ duration)
</pre></div></div><div class="top"><p class="src"><a name="v:hibernate" class="def">hibernate</a> ::  <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</p><div class="doc"><p>Instructs the process to <em>hibernate</em> for the given <code><a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a></code>. Note
 that no messages will be removed from the mailbox until after hibernation has
 ceased. This is equivalent to calling <code>threadDelay</code>.
</p></div></div><div class="top"><p class="src"><a name="v:hibernate_" class="def">hibernate_</a> ::  <a href="Control-Distributed-Process-Platform-Time.html#t:TimeInterval">TimeInterval</a> -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</p><div class="doc"><p>Version of <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:hibernate">hibernate</a></code> that can be used in handlers that ignore process state.
</p><pre> action (\(HibernatePlease delay) -&gt; hibernate_ delay)
</pre></div></div><div class="top"><p class="src"><a name="v:stop" class="def">stop</a> ::  <a href="Control-Distributed-Process-Platform.html#t:TerminateReason">TerminateReason</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</p><div class="doc"><p>Instructs the process to terminate, giving the supplied reason. If a valid
 <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:terminateHandler">terminateHandler</a></code> is installed, it will be called with the <code><a href="Control-Distributed-Process-Platform.html#t:TerminateReason">TerminateReason</a></code>
 returned from this call, along with the process state.
</p></div></div><div class="top"><p class="src"><a name="v:stop_" class="def">stop_</a> ::  <a href="Control-Distributed-Process-Platform.html#t:TerminateReason">TerminateReason</a> -&gt; s -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> (<a href="Control-Distributed-Process-Platform-ManagedProcess.html#t:ProcessAction">ProcessAction</a> s)</p><div class="doc"><p>Version of <code><a href="Control-Distributed-Process-Platform-ManagedProcess.html#v:stop">stop</a></code> that can be used in handlers that ignore process state.
</p><pre> action (\ClientError -&gt; stop_ TerminateNormal)
</pre></div></div><div class="top"><p class="src"><a name="v:replyTo" class="def">replyTo</a> :: <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Serializable.html#t:Serializable">Serializable</a> m =&gt; <a href="Control-Distributed-Process-Platform.html#t:Recipient">Recipient</a> -&gt; m -&gt; <a href="http://hackage.haskell.org/packages/archive/distributed-process/latest//doc/html/Control-Distributed-Process-Internal-Types.html#t:Process">Process</a> <a href="/Library/Frameworks/GHC.framework/Versions/7.4.2-x86_64/usr/share/doc/ghc/html/libraries/ghc-prim-0.2.0.0/GHC-Tuple.html#t:-40--41-">()</a></p></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.11.0</p></div></body></html>